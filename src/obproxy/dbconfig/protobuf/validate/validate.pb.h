// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validate/validate.proto

#ifndef PROTOBUF_INCLUDED_validate_2fvalidate_2eproto
#define PROTOBUF_INCLUDED_validate_2fvalidate_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_validate_2fvalidate_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_validate_2fvalidate_2eproto();
namespace validate {
class AnyRules;
class AnyRulesDefaultTypeInternal;
extern AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
class BoolRules;
class BoolRulesDefaultTypeInternal;
extern BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
class BytesRules;
class BytesRulesDefaultTypeInternal;
extern BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
class DoubleRules;
class DoubleRulesDefaultTypeInternal;
extern DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
class DurationRules;
class DurationRulesDefaultTypeInternal;
extern DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
class EnumRules;
class EnumRulesDefaultTypeInternal;
extern EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
class FieldRules;
class FieldRulesDefaultTypeInternal;
extern FieldRulesDefaultTypeInternal _FieldRules_default_instance_;
class Fixed32Rules;
class Fixed32RulesDefaultTypeInternal;
extern Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
class Fixed64Rules;
class Fixed64RulesDefaultTypeInternal;
extern Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
class FloatRules;
class FloatRulesDefaultTypeInternal;
extern FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
class Int32Rules;
class Int32RulesDefaultTypeInternal;
extern Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
class Int64Rules;
class Int64RulesDefaultTypeInternal;
extern Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
class MapRules;
class MapRulesDefaultTypeInternal;
extern MapRulesDefaultTypeInternal _MapRules_default_instance_;
class MessageRules;
class MessageRulesDefaultTypeInternal;
extern MessageRulesDefaultTypeInternal _MessageRules_default_instance_;
class RepeatedRules;
class RepeatedRulesDefaultTypeInternal;
extern RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
class SFixed32Rules;
class SFixed32RulesDefaultTypeInternal;
extern SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
class SFixed64Rules;
class SFixed64RulesDefaultTypeInternal;
extern SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
class SInt32Rules;
class SInt32RulesDefaultTypeInternal;
extern SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
class SInt64Rules;
class SInt64RulesDefaultTypeInternal;
extern SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
class StringRules;
class StringRulesDefaultTypeInternal;
extern StringRulesDefaultTypeInternal _StringRules_default_instance_;
class TimestampRules;
class TimestampRulesDefaultTypeInternal;
extern TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
class UInt32Rules;
class UInt32RulesDefaultTypeInternal;
extern UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
class UInt64Rules;
class UInt64RulesDefaultTypeInternal;
extern UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
}  // namespace validate
namespace google {
namespace protobuf {
template<> ::validate::AnyRules* Arena::CreateMaybeMessage<::validate::AnyRules>(Arena*);
template<> ::validate::BoolRules* Arena::CreateMaybeMessage<::validate::BoolRules>(Arena*);
template<> ::validate::BytesRules* Arena::CreateMaybeMessage<::validate::BytesRules>(Arena*);
template<> ::validate::DoubleRules* Arena::CreateMaybeMessage<::validate::DoubleRules>(Arena*);
template<> ::validate::DurationRules* Arena::CreateMaybeMessage<::validate::DurationRules>(Arena*);
template<> ::validate::EnumRules* Arena::CreateMaybeMessage<::validate::EnumRules>(Arena*);
template<> ::validate::FieldRules* Arena::CreateMaybeMessage<::validate::FieldRules>(Arena*);
template<> ::validate::Fixed32Rules* Arena::CreateMaybeMessage<::validate::Fixed32Rules>(Arena*);
template<> ::validate::Fixed64Rules* Arena::CreateMaybeMessage<::validate::Fixed64Rules>(Arena*);
template<> ::validate::FloatRules* Arena::CreateMaybeMessage<::validate::FloatRules>(Arena*);
template<> ::validate::Int32Rules* Arena::CreateMaybeMessage<::validate::Int32Rules>(Arena*);
template<> ::validate::Int64Rules* Arena::CreateMaybeMessage<::validate::Int64Rules>(Arena*);
template<> ::validate::MapRules* Arena::CreateMaybeMessage<::validate::MapRules>(Arena*);
template<> ::validate::MessageRules* Arena::CreateMaybeMessage<::validate::MessageRules>(Arena*);
template<> ::validate::RepeatedRules* Arena::CreateMaybeMessage<::validate::RepeatedRules>(Arena*);
template<> ::validate::SFixed32Rules* Arena::CreateMaybeMessage<::validate::SFixed32Rules>(Arena*);
template<> ::validate::SFixed64Rules* Arena::CreateMaybeMessage<::validate::SFixed64Rules>(Arena*);
template<> ::validate::SInt32Rules* Arena::CreateMaybeMessage<::validate::SInt32Rules>(Arena*);
template<> ::validate::SInt64Rules* Arena::CreateMaybeMessage<::validate::SInt64Rules>(Arena*);
template<> ::validate::StringRules* Arena::CreateMaybeMessage<::validate::StringRules>(Arena*);
template<> ::validate::TimestampRules* Arena::CreateMaybeMessage<::validate::TimestampRules>(Arena*);
template<> ::validate::UInt32Rules* Arena::CreateMaybeMessage<::validate::UInt32Rules>(Arena*);
template<> ::validate::UInt64Rules* Arena::CreateMaybeMessage<::validate::UInt64Rules>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace validate {

// ===================================================================

class FieldRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.FieldRules) */ {
 public:
  FieldRules();
  virtual ~FieldRules();

  FieldRules(const FieldRules& from);

  inline FieldRules& operator=(const FieldRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldRules(FieldRules&& from) noexcept
    : FieldRules() {
    *this = ::std::move(from);
  }

  inline FieldRules& operator=(FieldRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FieldRules& default_instance();

  enum TypeCase {
    kFloat = 1,
    kDouble = 2,
    kInt32 = 3,
    kInt64 = 4,
    kUint32 = 5,
    kUint64 = 6,
    kSint32 = 7,
    kSint64 = 8,
    kFixed32 = 9,
    kFixed64 = 10,
    kSfixed32 = 11,
    kSfixed64 = 12,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    kEnum = 16,
    kMessage = 17,
    kRepeated = 18,
    kMap = 19,
    kAny = 20,
    kDuration = 21,
    kTimestamp = 22,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FieldRules* internal_default_instance() {
    return reinterpret_cast<const FieldRules*>(
               &_FieldRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FieldRules* other);
  friend void swap(FieldRules& a, FieldRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldRules* New() const final {
    return CreateMaybeMessage<FieldRules>(nullptr);
  }

  FieldRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FieldRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FieldRules& from);
  void MergeFrom(const FieldRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .validate.FloatRules float = 1;
  bool has_float_() const;
  void clear_float_();
  static const int kFloatFieldNumber = 1;
  const ::validate::FloatRules& float_() const;
  ::validate::FloatRules* release_float_();
  ::validate::FloatRules* mutable_float_();
  void set_allocated_float_(::validate::FloatRules* float_);

  // optional .validate.DoubleRules double = 2;
  bool has_double_() const;
  void clear_double_();
  static const int kDoubleFieldNumber = 2;
  const ::validate::DoubleRules& double_() const;
  ::validate::DoubleRules* release_double_();
  ::validate::DoubleRules* mutable_double_();
  void set_allocated_double_(::validate::DoubleRules* double_);

  // optional .validate.Int32Rules int32 = 3;
  bool has_int32() const;
  void clear_int32();
  static const int kInt32FieldNumber = 3;
  const ::validate::Int32Rules& int32() const;
  ::validate::Int32Rules* release_int32();
  ::validate::Int32Rules* mutable_int32();
  void set_allocated_int32(::validate::Int32Rules* int32);

  // optional .validate.Int64Rules int64 = 4;
  bool has_int64() const;
  void clear_int64();
  static const int kInt64FieldNumber = 4;
  const ::validate::Int64Rules& int64() const;
  ::validate::Int64Rules* release_int64();
  ::validate::Int64Rules* mutable_int64();
  void set_allocated_int64(::validate::Int64Rules* int64);

  // optional .validate.UInt32Rules uint32 = 5;
  bool has_uint32() const;
  void clear_uint32();
  static const int kUint32FieldNumber = 5;
  const ::validate::UInt32Rules& uint32() const;
  ::validate::UInt32Rules* release_uint32();
  ::validate::UInt32Rules* mutable_uint32();
  void set_allocated_uint32(::validate::UInt32Rules* uint32);

  // optional .validate.UInt64Rules uint64 = 6;
  bool has_uint64() const;
  void clear_uint64();
  static const int kUint64FieldNumber = 6;
  const ::validate::UInt64Rules& uint64() const;
  ::validate::UInt64Rules* release_uint64();
  ::validate::UInt64Rules* mutable_uint64();
  void set_allocated_uint64(::validate::UInt64Rules* uint64);

  // optional .validate.SInt32Rules sint32 = 7;
  bool has_sint32() const;
  void clear_sint32();
  static const int kSint32FieldNumber = 7;
  const ::validate::SInt32Rules& sint32() const;
  ::validate::SInt32Rules* release_sint32();
  ::validate::SInt32Rules* mutable_sint32();
  void set_allocated_sint32(::validate::SInt32Rules* sint32);

  // optional .validate.SInt64Rules sint64 = 8;
  bool has_sint64() const;
  void clear_sint64();
  static const int kSint64FieldNumber = 8;
  const ::validate::SInt64Rules& sint64() const;
  ::validate::SInt64Rules* release_sint64();
  ::validate::SInt64Rules* mutable_sint64();
  void set_allocated_sint64(::validate::SInt64Rules* sint64);

  // optional .validate.Fixed32Rules fixed32 = 9;
  bool has_fixed32() const;
  void clear_fixed32();
  static const int kFixed32FieldNumber = 9;
  const ::validate::Fixed32Rules& fixed32() const;
  ::validate::Fixed32Rules* release_fixed32();
  ::validate::Fixed32Rules* mutable_fixed32();
  void set_allocated_fixed32(::validate::Fixed32Rules* fixed32);

  // optional .validate.Fixed64Rules fixed64 = 10;
  bool has_fixed64() const;
  void clear_fixed64();
  static const int kFixed64FieldNumber = 10;
  const ::validate::Fixed64Rules& fixed64() const;
  ::validate::Fixed64Rules* release_fixed64();
  ::validate::Fixed64Rules* mutable_fixed64();
  void set_allocated_fixed64(::validate::Fixed64Rules* fixed64);

  // optional .validate.SFixed32Rules sfixed32 = 11;
  bool has_sfixed32() const;
  void clear_sfixed32();
  static const int kSfixed32FieldNumber = 11;
  const ::validate::SFixed32Rules& sfixed32() const;
  ::validate::SFixed32Rules* release_sfixed32();
  ::validate::SFixed32Rules* mutable_sfixed32();
  void set_allocated_sfixed32(::validate::SFixed32Rules* sfixed32);

  // optional .validate.SFixed64Rules sfixed64 = 12;
  bool has_sfixed64() const;
  void clear_sfixed64();
  static const int kSfixed64FieldNumber = 12;
  const ::validate::SFixed64Rules& sfixed64() const;
  ::validate::SFixed64Rules* release_sfixed64();
  ::validate::SFixed64Rules* mutable_sfixed64();
  void set_allocated_sfixed64(::validate::SFixed64Rules* sfixed64);

  // optional .validate.BoolRules bool = 13;
  bool has_bool_() const;
  void clear_bool_();
  static const int kBoolFieldNumber = 13;
  const ::validate::BoolRules& bool_() const;
  ::validate::BoolRules* release_bool_();
  ::validate::BoolRules* mutable_bool_();
  void set_allocated_bool_(::validate::BoolRules* bool_);

  // optional .validate.StringRules string = 14;
  bool has_string() const;
  void clear_string();
  static const int kStringFieldNumber = 14;
  const ::validate::StringRules& string() const;
  ::validate::StringRules* release_string();
  ::validate::StringRules* mutable_string();
  void set_allocated_string(::validate::StringRules* string);

  // optional .validate.BytesRules bytes = 15;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 15;
  const ::validate::BytesRules& bytes() const;
  ::validate::BytesRules* release_bytes();
  ::validate::BytesRules* mutable_bytes();
  void set_allocated_bytes(::validate::BytesRules* bytes);

  // optional .validate.EnumRules enum = 16;
  bool has_enum_() const;
  void clear_enum_();
  static const int kEnumFieldNumber = 16;
  const ::validate::EnumRules& enum_() const;
  ::validate::EnumRules* release_enum_();
  ::validate::EnumRules* mutable_enum_();
  void set_allocated_enum_(::validate::EnumRules* enum_);

  // optional .validate.MessageRules message = 17;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 17;
  const ::validate::MessageRules& message() const;
  ::validate::MessageRules* release_message();
  ::validate::MessageRules* mutable_message();
  void set_allocated_message(::validate::MessageRules* message);

  // optional .validate.RepeatedRules repeated = 18;
  bool has_repeated() const;
  void clear_repeated();
  static const int kRepeatedFieldNumber = 18;
  const ::validate::RepeatedRules& repeated() const;
  ::validate::RepeatedRules* release_repeated();
  ::validate::RepeatedRules* mutable_repeated();
  void set_allocated_repeated(::validate::RepeatedRules* repeated);

  // optional .validate.MapRules map = 19;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 19;
  const ::validate::MapRules& map() const;
  ::validate::MapRules* release_map();
  ::validate::MapRules* mutable_map();
  void set_allocated_map(::validate::MapRules* map);

  // optional .validate.AnyRules any = 20;
  bool has_any() const;
  void clear_any();
  static const int kAnyFieldNumber = 20;
  const ::validate::AnyRules& any() const;
  ::validate::AnyRules* release_any();
  ::validate::AnyRules* mutable_any();
  void set_allocated_any(::validate::AnyRules* any);

  // optional .validate.DurationRules duration = 21;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 21;
  const ::validate::DurationRules& duration() const;
  ::validate::DurationRules* release_duration();
  ::validate::DurationRules* mutable_duration();
  void set_allocated_duration(::validate::DurationRules* duration);

  // optional .validate.TimestampRules timestamp = 22;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 22;
  const ::validate::TimestampRules& timestamp() const;
  ::validate::TimestampRules* release_timestamp();
  ::validate::TimestampRules* mutable_timestamp();
  void set_allocated_timestamp(::validate::TimestampRules* timestamp);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:validate.FieldRules)
 private:
  class HasBitSetters;
  void set_has_float_();
  void set_has_double_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_sint32();
  void set_has_sint64();
  void set_has_fixed32();
  void set_has_fixed64();
  void set_has_sfixed32();
  void set_has_sfixed64();
  void set_has_bool_();
  void set_has_string();
  void set_has_bytes();
  void set_has_enum_();
  void set_has_message();
  void set_has_repeated();
  void set_has_map();
  void set_has_any();
  void set_has_duration();
  void set_has_timestamp();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union TypeUnion {
    TypeUnion() {}
    ::validate::FloatRules* float__;
    ::validate::DoubleRules* double__;
    ::validate::Int32Rules* int32_;
    ::validate::Int64Rules* int64_;
    ::validate::UInt32Rules* uint32_;
    ::validate::UInt64Rules* uint64_;
    ::validate::SInt32Rules* sint32_;
    ::validate::SInt64Rules* sint64_;
    ::validate::Fixed32Rules* fixed32_;
    ::validate::Fixed64Rules* fixed64_;
    ::validate::SFixed32Rules* sfixed32_;
    ::validate::SFixed64Rules* sfixed64_;
    ::validate::BoolRules* bool__;
    ::validate::StringRules* string_;
    ::validate::BytesRules* bytes_;
    ::validate::EnumRules* enum__;
    ::validate::MessageRules* message_;
    ::validate::RepeatedRules* repeated_;
    ::validate::MapRules* map_;
    ::validate::AnyRules* any_;
    ::validate::DurationRules* duration_;
    ::validate::TimestampRules* timestamp_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class FloatRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.FloatRules) */ {
 public:
  FloatRules();
  virtual ~FloatRules();

  FloatRules(const FloatRules& from);

  inline FloatRules& operator=(const FloatRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatRules(FloatRules&& from) noexcept
    : FloatRules() {
    *this = ::std::move(from);
  }

  inline FloatRules& operator=(FloatRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FloatRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatRules* internal_default_instance() {
    return reinterpret_cast<const FloatRules*>(
               &_FloatRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FloatRules* other);
  friend void swap(FloatRules& a, FloatRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatRules* New() const final {
    return CreateMaybeMessage<FloatRules>(nullptr);
  }

  FloatRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatRules& from);
  void MergeFrom(const FloatRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  float in(int index) const;
  void set_in(int index, float value);
  void add_in(float value);
  const ::google::protobuf::RepeatedField< float >&
      in() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_in();

  // repeated float not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  float not_in(int index) const;
  void set_not_in(int index, float value);
  void add_not_in(float value);
  const ::google::protobuf::RepeatedField< float >&
      not_in() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_not_in();

  // optional float const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  float const_() const;
  void set_const_(float value);

  // optional float lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  float lt() const;
  void set_lt(float value);

  // optional float lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  float lte() const;
  void set_lte(float value);

  // optional float gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  float gt() const;
  void set_gt(float value);

  // optional float gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  float gte() const;
  void set_gte(float value);

  // @@protoc_insertion_point(class_scope:validate.FloatRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > in_;
  ::google::protobuf::RepeatedField< float > not_in_;
  float const__;
  float lt_;
  float lte_;
  float gt_;
  float gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class DoubleRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.DoubleRules) */ {
 public:
  DoubleRules();
  virtual ~DoubleRules();

  DoubleRules(const DoubleRules& from);

  inline DoubleRules& operator=(const DoubleRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleRules(DoubleRules&& from) noexcept
    : DoubleRules() {
    *this = ::std::move(from);
  }

  inline DoubleRules& operator=(DoubleRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DoubleRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleRules* internal_default_instance() {
    return reinterpret_cast<const DoubleRules*>(
               &_DoubleRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DoubleRules* other);
  friend void swap(DoubleRules& a, DoubleRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleRules* New() const final {
    return CreateMaybeMessage<DoubleRules>(nullptr);
  }

  DoubleRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleRules& from);
  void MergeFrom(const DoubleRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  double in(int index) const;
  void set_in(int index, double value);
  void add_in(double value);
  const ::google::protobuf::RepeatedField< double >&
      in() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_in();

  // repeated double not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  double not_in(int index) const;
  void set_not_in(int index, double value);
  void add_not_in(double value);
  const ::google::protobuf::RepeatedField< double >&
      not_in() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_not_in();

  // optional double const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  double const_() const;
  void set_const_(double value);

  // optional double lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  double lt() const;
  void set_lt(double value);

  // optional double lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  double lte() const;
  void set_lte(double value);

  // optional double gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  double gt() const;
  void set_gt(double value);

  // optional double gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  double gte() const;
  void set_gte(double value);

  // @@protoc_insertion_point(class_scope:validate.DoubleRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > in_;
  ::google::protobuf::RepeatedField< double > not_in_;
  double const__;
  double lt_;
  double lte_;
  double gt_;
  double gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Int32Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Int32Rules) */ {
 public:
  Int32Rules();
  virtual ~Int32Rules();

  Int32Rules(const Int32Rules& from);

  inline Int32Rules& operator=(const Int32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32Rules(Int32Rules&& from) noexcept
    : Int32Rules() {
    *this = ::std::move(from);
  }

  inline Int32Rules& operator=(Int32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Int32Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32Rules* internal_default_instance() {
    return reinterpret_cast<const Int32Rules*>(
               &_Int32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Int32Rules* other);
  friend void swap(Int32Rules& a, Int32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32Rules* New() const final {
    return CreateMaybeMessage<Int32Rules>(nullptr);
  }

  Int32Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int32Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int32Rules& from);
  void MergeFrom(const Int32Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated int32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional int32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional int32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // optional int32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // optional int32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // optional int32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:validate.Int32Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  ::google::protobuf::int32 lt_;
  ::google::protobuf::int32 lte_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Int64Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Int64Rules) */ {
 public:
  Int64Rules();
  virtual ~Int64Rules();

  Int64Rules(const Int64Rules& from);

  inline Int64Rules& operator=(const Int64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64Rules(Int64Rules&& from) noexcept
    : Int64Rules() {
    *this = ::std::move(from);
  }

  inline Int64Rules& operator=(Int64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Int64Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64Rules* internal_default_instance() {
    return reinterpret_cast<const Int64Rules*>(
               &_Int64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Int64Rules* other);
  friend void swap(Int64Rules& a, Int64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64Rules* New() const final {
    return CreateMaybeMessage<Int64Rules>(nullptr);
  }

  Int64Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int64Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int64Rules& from);
  void MergeFrom(const Int64Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated int64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // optional int64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int64 const_() const;
  void set_const_(::google::protobuf::int64 value);

  // optional int64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // optional int64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // optional int64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // optional int64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:validate.Int64Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  ::google::protobuf::int64 const__;
  ::google::protobuf::int64 lt_;
  ::google::protobuf::int64 lte_;
  ::google::protobuf::int64 gt_;
  ::google::protobuf::int64 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class UInt32Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.UInt32Rules) */ {
 public:
  UInt32Rules();
  virtual ~UInt32Rules();

  UInt32Rules(const UInt32Rules& from);

  inline UInt32Rules& operator=(const UInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt32Rules(UInt32Rules&& from) noexcept
    : UInt32Rules() {
    *this = ::std::move(from);
  }

  inline UInt32Rules& operator=(UInt32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UInt32Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt32Rules* internal_default_instance() {
    return reinterpret_cast<const UInt32Rules*>(
               &_UInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(UInt32Rules* other);
  friend void swap(UInt32Rules& a, UInt32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt32Rules* New() const final {
    return CreateMaybeMessage<UInt32Rules>(nullptr);
  }

  UInt32Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInt32Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInt32Rules& from);
  void MergeFrom(const UInt32Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint32 in(int index) const;
  void set_in(int index, ::google::protobuf::uint32 value);
  void add_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_in();

  // repeated uint32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint32 value);
  void add_not_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_not_in();

  // optional uint32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint32 const_() const;
  void set_const_(::google::protobuf::uint32 value);

  // optional uint32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint32 lt() const;
  void set_lt(::google::protobuf::uint32 value);

  // optional uint32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint32 lte() const;
  void set_lte(::google::protobuf::uint32 value);

  // optional uint32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint32 gt() const;
  void set_gt(::google::protobuf::uint32 value);

  // optional uint32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint32 gte() const;
  void set_gte(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:validate.UInt32Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > not_in_;
  ::google::protobuf::uint32 const__;
  ::google::protobuf::uint32 lt_;
  ::google::protobuf::uint32 lte_;
  ::google::protobuf::uint32 gt_;
  ::google::protobuf::uint32 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class UInt64Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.UInt64Rules) */ {
 public:
  UInt64Rules();
  virtual ~UInt64Rules();

  UInt64Rules(const UInt64Rules& from);

  inline UInt64Rules& operator=(const UInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt64Rules(UInt64Rules&& from) noexcept
    : UInt64Rules() {
    *this = ::std::move(from);
  }

  inline UInt64Rules& operator=(UInt64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UInt64Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt64Rules* internal_default_instance() {
    return reinterpret_cast<const UInt64Rules*>(
               &_UInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UInt64Rules* other);
  friend void swap(UInt64Rules& a, UInt64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt64Rules* New() const final {
    return CreateMaybeMessage<UInt64Rules>(nullptr);
  }

  UInt64Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInt64Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInt64Rules& from);
  void MergeFrom(const UInt64Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint64 in(int index) const;
  void set_in(int index, ::google::protobuf::uint64 value);
  void add_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_in();

  // repeated uint64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint64 value);
  void add_not_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_not_in();

  // optional uint64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint64 const_() const;
  void set_const_(::google::protobuf::uint64 value);

  // optional uint64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint64 lt() const;
  void set_lt(::google::protobuf::uint64 value);

  // optional uint64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint64 lte() const;
  void set_lte(::google::protobuf::uint64 value);

  // optional uint64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint64 gt() const;
  void set_gt(::google::protobuf::uint64 value);

  // optional uint64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint64 gte() const;
  void set_gte(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:validate.UInt64Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > not_in_;
  ::google::protobuf::uint64 const__;
  ::google::protobuf::uint64 lt_;
  ::google::protobuf::uint64 lte_;
  ::google::protobuf::uint64 gt_;
  ::google::protobuf::uint64 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SInt32Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SInt32Rules) */ {
 public:
  SInt32Rules();
  virtual ~SInt32Rules();

  SInt32Rules(const SInt32Rules& from);

  inline SInt32Rules& operator=(const SInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SInt32Rules(SInt32Rules&& from) noexcept
    : SInt32Rules() {
    *this = ::std::move(from);
  }

  inline SInt32Rules& operator=(SInt32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SInt32Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SInt32Rules* internal_default_instance() {
    return reinterpret_cast<const SInt32Rules*>(
               &_SInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SInt32Rules* other);
  friend void swap(SInt32Rules& a, SInt32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SInt32Rules* New() const final {
    return CreateMaybeMessage<SInt32Rules>(nullptr);
  }

  SInt32Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SInt32Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SInt32Rules& from);
  void MergeFrom(const SInt32Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SInt32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated sint32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional sint32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional sint32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // optional sint32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // optional sint32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // optional sint32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:validate.SInt32Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  ::google::protobuf::int32 lt_;
  ::google::protobuf::int32 lte_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SInt64Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SInt64Rules) */ {
 public:
  SInt64Rules();
  virtual ~SInt64Rules();

  SInt64Rules(const SInt64Rules& from);

  inline SInt64Rules& operator=(const SInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SInt64Rules(SInt64Rules&& from) noexcept
    : SInt64Rules() {
    *this = ::std::move(from);
  }

  inline SInt64Rules& operator=(SInt64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SInt64Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SInt64Rules* internal_default_instance() {
    return reinterpret_cast<const SInt64Rules*>(
               &_SInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SInt64Rules* other);
  friend void swap(SInt64Rules& a, SInt64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SInt64Rules* New() const final {
    return CreateMaybeMessage<SInt64Rules>(nullptr);
  }

  SInt64Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SInt64Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SInt64Rules& from);
  void MergeFrom(const SInt64Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SInt64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated sint64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // optional sint64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int64 const_() const;
  void set_const_(::google::protobuf::int64 value);

  // optional sint64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // optional sint64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // optional sint64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // optional sint64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:validate.SInt64Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  ::google::protobuf::int64 const__;
  ::google::protobuf::int64 lt_;
  ::google::protobuf::int64 lte_;
  ::google::protobuf::int64 gt_;
  ::google::protobuf::int64 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Fixed32Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Fixed32Rules) */ {
 public:
  Fixed32Rules();
  virtual ~Fixed32Rules();

  Fixed32Rules(const Fixed32Rules& from);

  inline Fixed32Rules& operator=(const Fixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fixed32Rules(Fixed32Rules&& from) noexcept
    : Fixed32Rules() {
    *this = ::std::move(from);
  }

  inline Fixed32Rules& operator=(Fixed32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Fixed32Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fixed32Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed32Rules*>(
               &_Fixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Fixed32Rules* other);
  friend void swap(Fixed32Rules& a, Fixed32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fixed32Rules* New() const final {
    return CreateMaybeMessage<Fixed32Rules>(nullptr);
  }

  Fixed32Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fixed32Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fixed32Rules& from);
  void MergeFrom(const Fixed32Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint32 in(int index) const;
  void set_in(int index, ::google::protobuf::uint32 value);
  void add_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_in();

  // repeated fixed32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint32 value);
  void add_not_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_not_in();

  // optional fixed32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint32 const_() const;
  void set_const_(::google::protobuf::uint32 value);

  // optional fixed32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint32 lt() const;
  void set_lt(::google::protobuf::uint32 value);

  // optional fixed32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint32 lte() const;
  void set_lte(::google::protobuf::uint32 value);

  // optional fixed32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint32 gt() const;
  void set_gt(::google::protobuf::uint32 value);

  // optional fixed32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint32 gte() const;
  void set_gte(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:validate.Fixed32Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > not_in_;
  ::google::protobuf::uint32 const__;
  ::google::protobuf::uint32 lt_;
  ::google::protobuf::uint32 lte_;
  ::google::protobuf::uint32 gt_;
  ::google::protobuf::uint32 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Fixed64Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Fixed64Rules) */ {
 public:
  Fixed64Rules();
  virtual ~Fixed64Rules();

  Fixed64Rules(const Fixed64Rules& from);

  inline Fixed64Rules& operator=(const Fixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fixed64Rules(Fixed64Rules&& from) noexcept
    : Fixed64Rules() {
    *this = ::std::move(from);
  }

  inline Fixed64Rules& operator=(Fixed64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Fixed64Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fixed64Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed64Rules*>(
               &_Fixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Fixed64Rules* other);
  friend void swap(Fixed64Rules& a, Fixed64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fixed64Rules* New() const final {
    return CreateMaybeMessage<Fixed64Rules>(nullptr);
  }

  Fixed64Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fixed64Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fixed64Rules& from);
  void MergeFrom(const Fixed64Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint64 in(int index) const;
  void set_in(int index, ::google::protobuf::uint64 value);
  void add_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_in();

  // repeated fixed64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint64 value);
  void add_not_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_not_in();

  // optional fixed64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint64 const_() const;
  void set_const_(::google::protobuf::uint64 value);

  // optional fixed64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint64 lt() const;
  void set_lt(::google::protobuf::uint64 value);

  // optional fixed64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint64 lte() const;
  void set_lte(::google::protobuf::uint64 value);

  // optional fixed64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint64 gt() const;
  void set_gt(::google::protobuf::uint64 value);

  // optional fixed64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint64 gte() const;
  void set_gte(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:validate.Fixed64Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > not_in_;
  ::google::protobuf::uint64 const__;
  ::google::protobuf::uint64 lt_;
  ::google::protobuf::uint64 lte_;
  ::google::protobuf::uint64 gt_;
  ::google::protobuf::uint64 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SFixed32Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SFixed32Rules) */ {
 public:
  SFixed32Rules();
  virtual ~SFixed32Rules();

  SFixed32Rules(const SFixed32Rules& from);

  inline SFixed32Rules& operator=(const SFixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SFixed32Rules(SFixed32Rules&& from) noexcept
    : SFixed32Rules() {
    *this = ::std::move(from);
  }

  inline SFixed32Rules& operator=(SFixed32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SFixed32Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SFixed32Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed32Rules*>(
               &_SFixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SFixed32Rules* other);
  friend void swap(SFixed32Rules& a, SFixed32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SFixed32Rules* New() const final {
    return CreateMaybeMessage<SFixed32Rules>(nullptr);
  }

  SFixed32Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SFixed32Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SFixed32Rules& from);
  void MergeFrom(const SFixed32Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFixed32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sfixed32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated sfixed32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional sfixed32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional sfixed32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // optional sfixed32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // optional sfixed32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // optional sfixed32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:validate.SFixed32Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  ::google::protobuf::int32 lt_;
  ::google::protobuf::int32 lte_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SFixed64Rules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SFixed64Rules) */ {
 public:
  SFixed64Rules();
  virtual ~SFixed64Rules();

  SFixed64Rules(const SFixed64Rules& from);

  inline SFixed64Rules& operator=(const SFixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SFixed64Rules(SFixed64Rules&& from) noexcept
    : SFixed64Rules() {
    *this = ::std::move(from);
  }

  inline SFixed64Rules& operator=(SFixed64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SFixed64Rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SFixed64Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed64Rules*>(
               &_SFixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SFixed64Rules* other);
  friend void swap(SFixed64Rules& a, SFixed64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SFixed64Rules* New() const final {
    return CreateMaybeMessage<SFixed64Rules>(nullptr);
  }

  SFixed64Rules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SFixed64Rules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SFixed64Rules& from);
  void MergeFrom(const SFixed64Rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFixed64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sfixed64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated sfixed64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // optional sfixed64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int64 const_() const;
  void set_const_(::google::protobuf::int64 value);

  // optional sfixed64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // optional sfixed64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // optional sfixed64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // optional sfixed64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:validate.SFixed64Rules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  ::google::protobuf::int64 const__;
  ::google::protobuf::int64 lt_;
  ::google::protobuf::int64 lte_;
  ::google::protobuf::int64 gt_;
  ::google::protobuf::int64 gte_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class BoolRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.BoolRules) */ {
 public:
  BoolRules();
  virtual ~BoolRules();

  BoolRules(const BoolRules& from);

  inline BoolRules& operator=(const BoolRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoolRules(BoolRules&& from) noexcept
    : BoolRules() {
    *this = ::std::move(from);
  }

  inline BoolRules& operator=(BoolRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BoolRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoolRules* internal_default_instance() {
    return reinterpret_cast<const BoolRules*>(
               &_BoolRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BoolRules* other);
  friend void swap(BoolRules& a, BoolRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoolRules* New() const final {
    return CreateMaybeMessage<BoolRules>(nullptr);
  }

  BoolRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoolRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoolRules& from);
  void MergeFrom(const BoolRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  bool const_() const;
  void set_const_(bool value);

  // @@protoc_insertion_point(class_scope:validate.BoolRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool const__;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class StringRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.StringRules) */ {
 public:
  StringRules();
  virtual ~StringRules();

  StringRules(const StringRules& from);

  inline StringRules& operator=(const StringRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringRules(StringRules&& from) noexcept
    : StringRules() {
    *this = ::std::move(from);
  }

  inline StringRules& operator=(StringRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StringRules& default_instance();

  enum WellKnownCase {
    kEmail = 12,
    kHostname = 13,
    kIp = 14,
    kIpv4 = 15,
    kIpv6 = 16,
    kUri = 17,
    kUriRef = 18,
    WELL_KNOWN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringRules* internal_default_instance() {
    return reinterpret_cast<const StringRules*>(
               &_StringRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(StringRules* other);
  friend void swap(StringRules& a, StringRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringRules* New() const final {
    return CreateMaybeMessage<StringRules>(nullptr);
  }

  StringRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringRules& from);
  void MergeFrom(const StringRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string in = 10;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 10;
  const ::std::string& in(int index) const;
  ::std::string* mutable_in(int index);
  void set_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in(int index, ::std::string&& value);
  #endif
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, size_t size);
  ::std::string* add_in();
  void add_in(const ::std::string& value);
  #if LANG_CXX11
  void add_in(::std::string&& value);
  #endif
  void add_in(const char* value);
  void add_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_in();

  // repeated string not_in = 11;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 11;
  const ::std::string& not_in(int index) const;
  ::std::string* mutable_not_in(int index);
  void set_not_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_not_in(int index, ::std::string&& value);
  #endif
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, size_t size);
  ::std::string* add_not_in();
  void add_not_in(const ::std::string& value);
  #if LANG_CXX11
  void add_not_in(::std::string&& value);
  #endif
  void add_not_in(const char* value);
  void add_not_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_not_in();

  // optional string const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  const ::std::string& const_() const;
  void set_const_(const ::std::string& value);
  #if LANG_CXX11
  void set_const_(::std::string&& value);
  #endif
  void set_const_(const char* value);
  void set_const_(const char* value, size_t size);
  ::std::string* mutable_const_();
  ::std::string* release_const_();
  void set_allocated_const_(::std::string* const_);

  // optional string pattern = 6;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 6;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // optional string prefix = 7;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 7;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // optional string suffix = 8;
  bool has_suffix() const;
  void clear_suffix();
  static const int kSuffixFieldNumber = 8;
  const ::std::string& suffix() const;
  void set_suffix(const ::std::string& value);
  #if LANG_CXX11
  void set_suffix(::std::string&& value);
  #endif
  void set_suffix(const char* value);
  void set_suffix(const char* value, size_t size);
  ::std::string* mutable_suffix();
  ::std::string* release_suffix();
  void set_allocated_suffix(::std::string* suffix);

  // optional string contains = 9;
  bool has_contains() const;
  void clear_contains();
  static const int kContainsFieldNumber = 9;
  const ::std::string& contains() const;
  void set_contains(const ::std::string& value);
  #if LANG_CXX11
  void set_contains(::std::string&& value);
  #endif
  void set_contains(const char* value);
  void set_contains(const char* value, size_t size);
  ::std::string* mutable_contains();
  ::std::string* release_contains();
  void set_allocated_contains(::std::string* contains);

  // optional uint64 min_len = 2;
  bool has_min_len() const;
  void clear_min_len();
  static const int kMinLenFieldNumber = 2;
  ::google::protobuf::uint64 min_len() const;
  void set_min_len(::google::protobuf::uint64 value);

  // optional uint64 max_len = 3;
  bool has_max_len() const;
  void clear_max_len();
  static const int kMaxLenFieldNumber = 3;
  ::google::protobuf::uint64 max_len() const;
  void set_max_len(::google::protobuf::uint64 value);

  // optional uint64 min_bytes = 4;
  bool has_min_bytes() const;
  void clear_min_bytes();
  static const int kMinBytesFieldNumber = 4;
  ::google::protobuf::uint64 min_bytes() const;
  void set_min_bytes(::google::protobuf::uint64 value);

  // optional uint64 max_bytes = 5;
  bool has_max_bytes() const;
  void clear_max_bytes();
  static const int kMaxBytesFieldNumber = 5;
  ::google::protobuf::uint64 max_bytes() const;
  void set_max_bytes(::google::protobuf::uint64 value);

  // optional uint64 len = 19;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 19;
  ::google::protobuf::uint64 len() const;
  void set_len(::google::protobuf::uint64 value);

  // optional uint64 len_bytes = 20;
  bool has_len_bytes() const;
  void clear_len_bytes();
  static const int kLenBytesFieldNumber = 20;
  ::google::protobuf::uint64 len_bytes() const;
  void set_len_bytes(::google::protobuf::uint64 value);

  // optional bool email = 12;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 12;
  bool email() const;
  void set_email(bool value);

  // optional bool hostname = 13;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 13;
  bool hostname() const;
  void set_hostname(bool value);

  // optional bool ip = 14;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 14;
  bool ip() const;
  void set_ip(bool value);

  // optional bool ipv4 = 15;
  bool has_ipv4() const;
  void clear_ipv4();
  static const int kIpv4FieldNumber = 15;
  bool ipv4() const;
  void set_ipv4(bool value);

  // optional bool ipv6 = 16;
  bool has_ipv6() const;
  void clear_ipv6();
  static const int kIpv6FieldNumber = 16;
  bool ipv6() const;
  void set_ipv6(bool value);

  // optional bool uri = 17;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 17;
  bool uri() const;
  void set_uri(bool value);

  // optional bool uri_ref = 18;
  bool has_uri_ref() const;
  void clear_uri_ref();
  static const int kUriRefFieldNumber = 18;
  bool uri_ref() const;
  void set_uri_ref(bool value);

  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:validate.StringRules)
 private:
  class HasBitSetters;
  void set_has_email();
  void set_has_hostname();
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  void set_has_uri();
  void set_has_uri_ref();

  inline bool has_well_known() const;
  inline void clear_has_well_known();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> in_;
  ::google::protobuf::RepeatedPtrField<::std::string> not_in_;
  ::google::protobuf::internal::ArenaStringPtr const__;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr suffix_;
  ::google::protobuf::internal::ArenaStringPtr contains_;
  ::google::protobuf::uint64 min_len_;
  ::google::protobuf::uint64 max_len_;
  ::google::protobuf::uint64 min_bytes_;
  ::google::protobuf::uint64 max_bytes_;
  ::google::protobuf::uint64 len_;
  ::google::protobuf::uint64 len_bytes_;
  union WellKnownUnion {
    WellKnownUnion() {}
    bool email_;
    bool hostname_;
    bool ip_;
    bool ipv4_;
    bool ipv6_;
    bool uri_;
    bool uri_ref_;
  } well_known_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class BytesRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.BytesRules) */ {
 public:
  BytesRules();
  virtual ~BytesRules();

  BytesRules(const BytesRules& from);

  inline BytesRules& operator=(const BytesRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytesRules(BytesRules&& from) noexcept
    : BytesRules() {
    *this = ::std::move(from);
  }

  inline BytesRules& operator=(BytesRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BytesRules& default_instance();

  enum WellKnownCase {
    kIp = 10,
    kIpv4 = 11,
    kIpv6 = 12,
    WELL_KNOWN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytesRules* internal_default_instance() {
    return reinterpret_cast<const BytesRules*>(
               &_BytesRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(BytesRules* other);
  friend void swap(BytesRules& a, BytesRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytesRules* New() const final {
    return CreateMaybeMessage<BytesRules>(nullptr);
  }

  BytesRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytesRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytesRules& from);
  void MergeFrom(const BytesRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes in = 8;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 8;
  const ::std::string& in(int index) const;
  ::std::string* mutable_in(int index);
  void set_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in(int index, ::std::string&& value);
  #endif
  void set_in(int index, const char* value);
  void set_in(int index, const void* value, size_t size);
  ::std::string* add_in();
  void add_in(const ::std::string& value);
  #if LANG_CXX11
  void add_in(::std::string&& value);
  #endif
  void add_in(const char* value);
  void add_in(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_in();

  // repeated bytes not_in = 9;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 9;
  const ::std::string& not_in(int index) const;
  ::std::string* mutable_not_in(int index);
  void set_not_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_not_in(int index, ::std::string&& value);
  #endif
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const void* value, size_t size);
  ::std::string* add_not_in();
  void add_not_in(const ::std::string& value);
  #if LANG_CXX11
  void add_not_in(::std::string&& value);
  #endif
  void add_not_in(const char* value);
  void add_not_in(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_not_in();

  // optional bytes const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  const ::std::string& const_() const;
  void set_const_(const ::std::string& value);
  #if LANG_CXX11
  void set_const_(::std::string&& value);
  #endif
  void set_const_(const char* value);
  void set_const_(const void* value, size_t size);
  ::std::string* mutable_const_();
  ::std::string* release_const_();
  void set_allocated_const_(::std::string* const_);

  // optional string pattern = 4;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 4;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // optional bytes prefix = 5;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 5;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const void* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // optional bytes suffix = 6;
  bool has_suffix() const;
  void clear_suffix();
  static const int kSuffixFieldNumber = 6;
  const ::std::string& suffix() const;
  void set_suffix(const ::std::string& value);
  #if LANG_CXX11
  void set_suffix(::std::string&& value);
  #endif
  void set_suffix(const char* value);
  void set_suffix(const void* value, size_t size);
  ::std::string* mutable_suffix();
  ::std::string* release_suffix();
  void set_allocated_suffix(::std::string* suffix);

  // optional bytes contains = 7;
  bool has_contains() const;
  void clear_contains();
  static const int kContainsFieldNumber = 7;
  const ::std::string& contains() const;
  void set_contains(const ::std::string& value);
  #if LANG_CXX11
  void set_contains(::std::string&& value);
  #endif
  void set_contains(const char* value);
  void set_contains(const void* value, size_t size);
  ::std::string* mutable_contains();
  ::std::string* release_contains();
  void set_allocated_contains(::std::string* contains);

  // optional uint64 min_len = 2;
  bool has_min_len() const;
  void clear_min_len();
  static const int kMinLenFieldNumber = 2;
  ::google::protobuf::uint64 min_len() const;
  void set_min_len(::google::protobuf::uint64 value);

  // optional uint64 max_len = 3;
  bool has_max_len() const;
  void clear_max_len();
  static const int kMaxLenFieldNumber = 3;
  ::google::protobuf::uint64 max_len() const;
  void set_max_len(::google::protobuf::uint64 value);

  // optional uint64 len = 13;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 13;
  ::google::protobuf::uint64 len() const;
  void set_len(::google::protobuf::uint64 value);

  // optional bool ip = 10;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 10;
  bool ip() const;
  void set_ip(bool value);

  // optional bool ipv4 = 11;
  bool has_ipv4() const;
  void clear_ipv4();
  static const int kIpv4FieldNumber = 11;
  bool ipv4() const;
  void set_ipv4(bool value);

  // optional bool ipv6 = 12;
  bool has_ipv6() const;
  void clear_ipv6();
  static const int kIpv6FieldNumber = 12;
  bool ipv6() const;
  void set_ipv6(bool value);

  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:validate.BytesRules)
 private:
  class HasBitSetters;
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();

  inline bool has_well_known() const;
  inline void clear_has_well_known();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> in_;
  ::google::protobuf::RepeatedPtrField<::std::string> not_in_;
  ::google::protobuf::internal::ArenaStringPtr const__;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr suffix_;
  ::google::protobuf::internal::ArenaStringPtr contains_;
  ::google::protobuf::uint64 min_len_;
  ::google::protobuf::uint64 max_len_;
  ::google::protobuf::uint64 len_;
  union WellKnownUnion {
    WellKnownUnion() {}
    bool ip_;
    bool ipv4_;
    bool ipv6_;
  } well_known_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class EnumRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.EnumRules) */ {
 public:
  EnumRules();
  virtual ~EnumRules();

  EnumRules(const EnumRules& from);

  inline EnumRules& operator=(const EnumRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnumRules(EnumRules&& from) noexcept
    : EnumRules() {
    *this = ::std::move(from);
  }

  inline EnumRules& operator=(EnumRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EnumRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnumRules* internal_default_instance() {
    return reinterpret_cast<const EnumRules*>(
               &_EnumRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(EnumRules* other);
  friend void swap(EnumRules& a, EnumRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnumRules* New() const final {
    return CreateMaybeMessage<EnumRules>(nullptr);
  }

  EnumRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnumRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnumRules& from);
  void MergeFrom(const EnumRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 in = 3;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 3;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated int32 not_in = 4;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 4;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional int32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional bool defined_only = 2;
  bool has_defined_only() const;
  void clear_defined_only();
  static const int kDefinedOnlyFieldNumber = 2;
  bool defined_only() const;
  void set_defined_only(bool value);

  // @@protoc_insertion_point(class_scope:validate.EnumRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  bool defined_only_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class MessageRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.MessageRules) */ {
 public:
  MessageRules();
  virtual ~MessageRules();

  MessageRules(const MessageRules& from);

  inline MessageRules& operator=(const MessageRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageRules(MessageRules&& from) noexcept
    : MessageRules() {
    *this = ::std::move(from);
  }

  inline MessageRules& operator=(MessageRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessageRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageRules* internal_default_instance() {
    return reinterpret_cast<const MessageRules*>(
               &_MessageRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MessageRules* other);
  friend void swap(MessageRules& a, MessageRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageRules* New() const final {
    return CreateMaybeMessage<MessageRules>(nullptr);
  }

  MessageRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageRules& from);
  void MergeFrom(const MessageRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool skip = 1;
  bool has_skip() const;
  void clear_skip();
  static const int kSkipFieldNumber = 1;
  bool skip() const;
  void set_skip(bool value);

  // optional bool required = 2;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 2;
  bool required() const;
  void set_required(bool value);

  // @@protoc_insertion_point(class_scope:validate.MessageRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool skip_;
  bool required_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class RepeatedRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.RepeatedRules) */ {
 public:
  RepeatedRules();
  virtual ~RepeatedRules();

  RepeatedRules(const RepeatedRules& from);

  inline RepeatedRules& operator=(const RepeatedRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatedRules(RepeatedRules&& from) noexcept
    : RepeatedRules() {
    *this = ::std::move(from);
  }

  inline RepeatedRules& operator=(RepeatedRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RepeatedRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepeatedRules* internal_default_instance() {
    return reinterpret_cast<const RepeatedRules*>(
               &_RepeatedRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RepeatedRules* other);
  friend void swap(RepeatedRules& a, RepeatedRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatedRules* New() const final {
    return CreateMaybeMessage<RepeatedRules>(nullptr);
  }

  RepeatedRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepeatedRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepeatedRules& from);
  void MergeFrom(const RepeatedRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .validate.FieldRules items = 4;
  bool has_items() const;
  void clear_items();
  static const int kItemsFieldNumber = 4;
  const ::validate::FieldRules& items() const;
  ::validate::FieldRules* release_items();
  ::validate::FieldRules* mutable_items();
  void set_allocated_items(::validate::FieldRules* items);

  // optional uint64 min_items = 1;
  bool has_min_items() const;
  void clear_min_items();
  static const int kMinItemsFieldNumber = 1;
  ::google::protobuf::uint64 min_items() const;
  void set_min_items(::google::protobuf::uint64 value);

  // optional uint64 max_items = 2;
  bool has_max_items() const;
  void clear_max_items();
  static const int kMaxItemsFieldNumber = 2;
  ::google::protobuf::uint64 max_items() const;
  void set_max_items(::google::protobuf::uint64 value);

  // optional bool unique = 3;
  bool has_unique() const;
  void clear_unique();
  static const int kUniqueFieldNumber = 3;
  bool unique() const;
  void set_unique(bool value);

  // @@protoc_insertion_point(class_scope:validate.RepeatedRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::validate::FieldRules* items_;
  ::google::protobuf::uint64 min_items_;
  ::google::protobuf::uint64 max_items_;
  bool unique_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class MapRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.MapRules) */ {
 public:
  MapRules();
  virtual ~MapRules();

  MapRules(const MapRules& from);

  inline MapRules& operator=(const MapRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapRules(MapRules&& from) noexcept
    : MapRules() {
    *this = ::std::move(from);
  }

  inline MapRules& operator=(MapRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MapRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapRules* internal_default_instance() {
    return reinterpret_cast<const MapRules*>(
               &_MapRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(MapRules* other);
  friend void swap(MapRules& a, MapRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapRules* New() const final {
    return CreateMaybeMessage<MapRules>(nullptr);
  }

  MapRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapRules& from);
  void MergeFrom(const MapRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .validate.FieldRules keys = 4;
  bool has_keys() const;
  void clear_keys();
  static const int kKeysFieldNumber = 4;
  const ::validate::FieldRules& keys() const;
  ::validate::FieldRules* release_keys();
  ::validate::FieldRules* mutable_keys();
  void set_allocated_keys(::validate::FieldRules* keys);

  // optional .validate.FieldRules values = 5;
  bool has_values() const;
  void clear_values();
  static const int kValuesFieldNumber = 5;
  const ::validate::FieldRules& values() const;
  ::validate::FieldRules* release_values();
  ::validate::FieldRules* mutable_values();
  void set_allocated_values(::validate::FieldRules* values);

  // optional uint64 min_pairs = 1;
  bool has_min_pairs() const;
  void clear_min_pairs();
  static const int kMinPairsFieldNumber = 1;
  ::google::protobuf::uint64 min_pairs() const;
  void set_min_pairs(::google::protobuf::uint64 value);

  // optional uint64 max_pairs = 2;
  bool has_max_pairs() const;
  void clear_max_pairs();
  static const int kMaxPairsFieldNumber = 2;
  ::google::protobuf::uint64 max_pairs() const;
  void set_max_pairs(::google::protobuf::uint64 value);

  // optional bool no_sparse = 3;
  bool has_no_sparse() const;
  void clear_no_sparse();
  static const int kNoSparseFieldNumber = 3;
  bool no_sparse() const;
  void set_no_sparse(bool value);

  // @@protoc_insertion_point(class_scope:validate.MapRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::validate::FieldRules* keys_;
  ::validate::FieldRules* values_;
  ::google::protobuf::uint64 min_pairs_;
  ::google::protobuf::uint64 max_pairs_;
  bool no_sparse_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class AnyRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.AnyRules) */ {
 public:
  AnyRules();
  virtual ~AnyRules();

  AnyRules(const AnyRules& from);

  inline AnyRules& operator=(const AnyRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnyRules(AnyRules&& from) noexcept
    : AnyRules() {
    *this = ::std::move(from);
  }

  inline AnyRules& operator=(AnyRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AnyRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnyRules* internal_default_instance() {
    return reinterpret_cast<const AnyRules*>(
               &_AnyRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(AnyRules* other);
  friend void swap(AnyRules& a, AnyRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnyRules* New() const final {
    return CreateMaybeMessage<AnyRules>(nullptr);
  }

  AnyRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnyRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnyRules& from);
  void MergeFrom(const AnyRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string in = 2;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 2;
  const ::std::string& in(int index) const;
  ::std::string* mutable_in(int index);
  void set_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in(int index, ::std::string&& value);
  #endif
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, size_t size);
  ::std::string* add_in();
  void add_in(const ::std::string& value);
  #if LANG_CXX11
  void add_in(::std::string&& value);
  #endif
  void add_in(const char* value);
  void add_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_in();

  // repeated string not_in = 3;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 3;
  const ::std::string& not_in(int index) const;
  ::std::string* mutable_not_in(int index);
  void set_not_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_not_in(int index, ::std::string&& value);
  #endif
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, size_t size);
  ::std::string* add_not_in();
  void add_not_in(const ::std::string& value);
  #if LANG_CXX11
  void add_not_in(::std::string&& value);
  #endif
  void add_not_in(const char* value);
  void add_not_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_not_in();

  // optional bool required = 1;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 1;
  bool required() const;
  void set_required(bool value);

  // @@protoc_insertion_point(class_scope:validate.AnyRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> in_;
  ::google::protobuf::RepeatedPtrField<::std::string> not_in_;
  bool required_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class DurationRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.DurationRules) */ {
 public:
  DurationRules();
  virtual ~DurationRules();

  DurationRules(const DurationRules& from);

  inline DurationRules& operator=(const DurationRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DurationRules(DurationRules&& from) noexcept
    : DurationRules() {
    *this = ::std::move(from);
  }

  inline DurationRules& operator=(DurationRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DurationRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DurationRules* internal_default_instance() {
    return reinterpret_cast<const DurationRules*>(
               &_DurationRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(DurationRules* other);
  friend void swap(DurationRules& a, DurationRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DurationRules* New() const final {
    return CreateMaybeMessage<DurationRules>(nullptr);
  }

  DurationRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DurationRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DurationRules& from);
  void MergeFrom(const DurationRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DurationRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Duration in = 7;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 7;
  ::google::protobuf::Duration* mutable_in(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
      mutable_in();
  const ::google::protobuf::Duration& in(int index) const;
  ::google::protobuf::Duration* add_in();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
      in() const;

  // repeated .google.protobuf.Duration not_in = 8;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 8;
  ::google::protobuf::Duration* mutable_not_in(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
      mutable_not_in();
  const ::google::protobuf::Duration& not_in(int index) const;
  ::google::protobuf::Duration* add_not_in();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
      not_in() const;

  // optional .google.protobuf.Duration const = 2;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 2;
  const ::google::protobuf::Duration& const_() const;
  ::google::protobuf::Duration* release_const_();
  ::google::protobuf::Duration* mutable_const_();
  void set_allocated_const_(::google::protobuf::Duration* const_);

  // optional .google.protobuf.Duration lt = 3;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 3;
  const ::google::protobuf::Duration& lt() const;
  ::google::protobuf::Duration* release_lt();
  ::google::protobuf::Duration* mutable_lt();
  void set_allocated_lt(::google::protobuf::Duration* lt);

  // optional .google.protobuf.Duration lte = 4;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 4;
  const ::google::protobuf::Duration& lte() const;
  ::google::protobuf::Duration* release_lte();
  ::google::protobuf::Duration* mutable_lte();
  void set_allocated_lte(::google::protobuf::Duration* lte);

  // optional .google.protobuf.Duration gt = 5;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 5;
  const ::google::protobuf::Duration& gt() const;
  ::google::protobuf::Duration* release_gt();
  ::google::protobuf::Duration* mutable_gt();
  void set_allocated_gt(::google::protobuf::Duration* gt);

  // optional .google.protobuf.Duration gte = 6;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 6;
  const ::google::protobuf::Duration& gte() const;
  ::google::protobuf::Duration* release_gte();
  ::google::protobuf::Duration* mutable_gte();
  void set_allocated_gte(::google::protobuf::Duration* gte);

  // optional bool required = 1;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 1;
  bool required() const;
  void set_required(bool value);

  // @@protoc_insertion_point(class_scope:validate.DurationRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > in_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > not_in_;
  ::google::protobuf::Duration* const__;
  ::google::protobuf::Duration* lt_;
  ::google::protobuf::Duration* lte_;
  ::google::protobuf::Duration* gt_;
  ::google::protobuf::Duration* gte_;
  bool required_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class TimestampRules :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.TimestampRules) */ {
 public:
  TimestampRules();
  virtual ~TimestampRules();

  TimestampRules(const TimestampRules& from);

  inline TimestampRules& operator=(const TimestampRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimestampRules(TimestampRules&& from) noexcept
    : TimestampRules() {
    *this = ::std::move(from);
  }

  inline TimestampRules& operator=(TimestampRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TimestampRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimestampRules* internal_default_instance() {
    return reinterpret_cast<const TimestampRules*>(
               &_TimestampRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(TimestampRules* other);
  friend void swap(TimestampRules& a, TimestampRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimestampRules* New() const final {
    return CreateMaybeMessage<TimestampRules>(nullptr);
  }

  TimestampRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimestampRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimestampRules& from);
  void MergeFrom(const TimestampRules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimestampRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .google.protobuf.Timestamp const = 2;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 2;
  const ::google::protobuf::Timestamp& const_() const;
  ::google::protobuf::Timestamp* release_const_();
  ::google::protobuf::Timestamp* mutable_const_();
  void set_allocated_const_(::google::protobuf::Timestamp* const_);

  // optional .google.protobuf.Timestamp lt = 3;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 3;
  const ::google::protobuf::Timestamp& lt() const;
  ::google::protobuf::Timestamp* release_lt();
  ::google::protobuf::Timestamp* mutable_lt();
  void set_allocated_lt(::google::protobuf::Timestamp* lt);

  // optional .google.protobuf.Timestamp lte = 4;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 4;
  const ::google::protobuf::Timestamp& lte() const;
  ::google::protobuf::Timestamp* release_lte();
  ::google::protobuf::Timestamp* mutable_lte();
  void set_allocated_lte(::google::protobuf::Timestamp* lte);

  // optional .google.protobuf.Timestamp gt = 5;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 5;
  const ::google::protobuf::Timestamp& gt() const;
  ::google::protobuf::Timestamp* release_gt();
  ::google::protobuf::Timestamp* mutable_gt();
  void set_allocated_gt(::google::protobuf::Timestamp* gt);

  // optional .google.protobuf.Timestamp gte = 6;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 6;
  const ::google::protobuf::Timestamp& gte() const;
  ::google::protobuf::Timestamp* release_gte();
  ::google::protobuf::Timestamp* mutable_gte();
  void set_allocated_gte(::google::protobuf::Timestamp* gte);

  // optional .google.protobuf.Duration within = 9;
  bool has_within() const;
  void clear_within();
  static const int kWithinFieldNumber = 9;
  const ::google::protobuf::Duration& within() const;
  ::google::protobuf::Duration* release_within();
  ::google::protobuf::Duration* mutable_within();
  void set_allocated_within(::google::protobuf::Duration* within);

  // optional bool required = 1;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 1;
  bool required() const;
  void set_required(bool value);

  // optional bool lt_now = 7;
  bool has_lt_now() const;
  void clear_lt_now();
  static const int kLtNowFieldNumber = 7;
  bool lt_now() const;
  void set_lt_now(bool value);

  // optional bool gt_now = 8;
  bool has_gt_now() const;
  void clear_gt_now();
  static const int kGtNowFieldNumber = 8;
  bool gt_now() const;
  void set_gt_now(bool value);

  // @@protoc_insertion_point(class_scope:validate.TimestampRules)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::Timestamp* const__;
  ::google::protobuf::Timestamp* lt_;
  ::google::protobuf::Timestamp* lte_;
  ::google::protobuf::Timestamp* gt_;
  ::google::protobuf::Timestamp* gte_;
  ::google::protobuf::Duration* within_;
  bool required_;
  bool lt_now_;
  bool gt_now_;
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};
// ===================================================================

static const int kDisabledFieldNumber = 919191;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  disabled;
static const int kRequiredFieldNumber = 919191;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  required;
static const int kRulesFieldNumber = 919191;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::validate::FieldRules >, 11, false >
  rules;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FieldRules

// optional .validate.FloatRules float = 1;
inline bool FieldRules::has_float_() const {
  return type_case() == kFloat;
}
inline void FieldRules::set_has_float_() {
  _oneof_case_[0] = kFloat;
}
inline void FieldRules::clear_float_() {
  if (has_float_()) {
    delete type_.float__;
    clear_has_type();
  }
}
inline ::validate::FloatRules* FieldRules::release_float_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.float)
  if (has_float_()) {
    clear_has_type();
      ::validate::FloatRules* temp = type_.float__;
    type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::FloatRules& FieldRules::float_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.float)
  return has_float_()
      ? *type_.float__
      : *reinterpret_cast< ::validate::FloatRules*>(&::validate::_FloatRules_default_instance_);
}
inline ::validate::FloatRules* FieldRules::mutable_float_() {
  if (!has_float_()) {
    clear_type();
    set_has_float_();
    type_.float__ = CreateMaybeMessage< ::validate::FloatRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.float)
  return type_.float__;
}

// optional .validate.DoubleRules double = 2;
inline bool FieldRules::has_double_() const {
  return type_case() == kDouble;
}
inline void FieldRules::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void FieldRules::clear_double_() {
  if (has_double_()) {
    delete type_.double__;
    clear_has_type();
  }
}
inline ::validate::DoubleRules* FieldRules::release_double_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.double)
  if (has_double_()) {
    clear_has_type();
      ::validate::DoubleRules* temp = type_.double__;
    type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::DoubleRules& FieldRules::double_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.double)
  return has_double_()
      ? *type_.double__
      : *reinterpret_cast< ::validate::DoubleRules*>(&::validate::_DoubleRules_default_instance_);
}
inline ::validate::DoubleRules* FieldRules::mutable_double_() {
  if (!has_double_()) {
    clear_type();
    set_has_double_();
    type_.double__ = CreateMaybeMessage< ::validate::DoubleRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.double)
  return type_.double__;
}

// optional .validate.Int32Rules int32 = 3;
inline bool FieldRules::has_int32() const {
  return type_case() == kInt32;
}
inline void FieldRules::set_has_int32() {
  _oneof_case_[0] = kInt32;
}
inline void FieldRules::clear_int32() {
  if (has_int32()) {
    delete type_.int32_;
    clear_has_type();
  }
}
inline ::validate::Int32Rules* FieldRules::release_int32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.int32)
  if (has_int32()) {
    clear_has_type();
      ::validate::Int32Rules* temp = type_.int32_;
    type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Int32Rules& FieldRules::int32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.int32)
  return has_int32()
      ? *type_.int32_
      : *reinterpret_cast< ::validate::Int32Rules*>(&::validate::_Int32Rules_default_instance_);
}
inline ::validate::Int32Rules* FieldRules::mutable_int32() {
  if (!has_int32()) {
    clear_type();
    set_has_int32();
    type_.int32_ = CreateMaybeMessage< ::validate::Int32Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.int32)
  return type_.int32_;
}

// optional .validate.Int64Rules int64 = 4;
inline bool FieldRules::has_int64() const {
  return type_case() == kInt64;
}
inline void FieldRules::set_has_int64() {
  _oneof_case_[0] = kInt64;
}
inline void FieldRules::clear_int64() {
  if (has_int64()) {
    delete type_.int64_;
    clear_has_type();
  }
}
inline ::validate::Int64Rules* FieldRules::release_int64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.int64)
  if (has_int64()) {
    clear_has_type();
      ::validate::Int64Rules* temp = type_.int64_;
    type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Int64Rules& FieldRules::int64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.int64)
  return has_int64()
      ? *type_.int64_
      : *reinterpret_cast< ::validate::Int64Rules*>(&::validate::_Int64Rules_default_instance_);
}
inline ::validate::Int64Rules* FieldRules::mutable_int64() {
  if (!has_int64()) {
    clear_type();
    set_has_int64();
    type_.int64_ = CreateMaybeMessage< ::validate::Int64Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.int64)
  return type_.int64_;
}

// optional .validate.UInt32Rules uint32 = 5;
inline bool FieldRules::has_uint32() const {
  return type_case() == kUint32;
}
inline void FieldRules::set_has_uint32() {
  _oneof_case_[0] = kUint32;
}
inline void FieldRules::clear_uint32() {
  if (has_uint32()) {
    delete type_.uint32_;
    clear_has_type();
  }
}
inline ::validate::UInt32Rules* FieldRules::release_uint32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.uint32)
  if (has_uint32()) {
    clear_has_type();
      ::validate::UInt32Rules* temp = type_.uint32_;
    type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::UInt32Rules& FieldRules::uint32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.uint32)
  return has_uint32()
      ? *type_.uint32_
      : *reinterpret_cast< ::validate::UInt32Rules*>(&::validate::_UInt32Rules_default_instance_);
}
inline ::validate::UInt32Rules* FieldRules::mutable_uint32() {
  if (!has_uint32()) {
    clear_type();
    set_has_uint32();
    type_.uint32_ = CreateMaybeMessage< ::validate::UInt32Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.uint32)
  return type_.uint32_;
}

// optional .validate.UInt64Rules uint64 = 6;
inline bool FieldRules::has_uint64() const {
  return type_case() == kUint64;
}
inline void FieldRules::set_has_uint64() {
  _oneof_case_[0] = kUint64;
}
inline void FieldRules::clear_uint64() {
  if (has_uint64()) {
    delete type_.uint64_;
    clear_has_type();
  }
}
inline ::validate::UInt64Rules* FieldRules::release_uint64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.uint64)
  if (has_uint64()) {
    clear_has_type();
      ::validate::UInt64Rules* temp = type_.uint64_;
    type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::UInt64Rules& FieldRules::uint64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.uint64)
  return has_uint64()
      ? *type_.uint64_
      : *reinterpret_cast< ::validate::UInt64Rules*>(&::validate::_UInt64Rules_default_instance_);
}
inline ::validate::UInt64Rules* FieldRules::mutable_uint64() {
  if (!has_uint64()) {
    clear_type();
    set_has_uint64();
    type_.uint64_ = CreateMaybeMessage< ::validate::UInt64Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.uint64)
  return type_.uint64_;
}

// optional .validate.SInt32Rules sint32 = 7;
inline bool FieldRules::has_sint32() const {
  return type_case() == kSint32;
}
inline void FieldRules::set_has_sint32() {
  _oneof_case_[0] = kSint32;
}
inline void FieldRules::clear_sint32() {
  if (has_sint32()) {
    delete type_.sint32_;
    clear_has_type();
  }
}
inline ::validate::SInt32Rules* FieldRules::release_sint32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sint32)
  if (has_sint32()) {
    clear_has_type();
      ::validate::SInt32Rules* temp = type_.sint32_;
    type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SInt32Rules& FieldRules::sint32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sint32)
  return has_sint32()
      ? *type_.sint32_
      : *reinterpret_cast< ::validate::SInt32Rules*>(&::validate::_SInt32Rules_default_instance_);
}
inline ::validate::SInt32Rules* FieldRules::mutable_sint32() {
  if (!has_sint32()) {
    clear_type();
    set_has_sint32();
    type_.sint32_ = CreateMaybeMessage< ::validate::SInt32Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sint32)
  return type_.sint32_;
}

// optional .validate.SInt64Rules sint64 = 8;
inline bool FieldRules::has_sint64() const {
  return type_case() == kSint64;
}
inline void FieldRules::set_has_sint64() {
  _oneof_case_[0] = kSint64;
}
inline void FieldRules::clear_sint64() {
  if (has_sint64()) {
    delete type_.sint64_;
    clear_has_type();
  }
}
inline ::validate::SInt64Rules* FieldRules::release_sint64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sint64)
  if (has_sint64()) {
    clear_has_type();
      ::validate::SInt64Rules* temp = type_.sint64_;
    type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SInt64Rules& FieldRules::sint64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sint64)
  return has_sint64()
      ? *type_.sint64_
      : *reinterpret_cast< ::validate::SInt64Rules*>(&::validate::_SInt64Rules_default_instance_);
}
inline ::validate::SInt64Rules* FieldRules::mutable_sint64() {
  if (!has_sint64()) {
    clear_type();
    set_has_sint64();
    type_.sint64_ = CreateMaybeMessage< ::validate::SInt64Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sint64)
  return type_.sint64_;
}

// optional .validate.Fixed32Rules fixed32 = 9;
inline bool FieldRules::has_fixed32() const {
  return type_case() == kFixed32;
}
inline void FieldRules::set_has_fixed32() {
  _oneof_case_[0] = kFixed32;
}
inline void FieldRules::clear_fixed32() {
  if (has_fixed32()) {
    delete type_.fixed32_;
    clear_has_type();
  }
}
inline ::validate::Fixed32Rules* FieldRules::release_fixed32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.fixed32)
  if (has_fixed32()) {
    clear_has_type();
      ::validate::Fixed32Rules* temp = type_.fixed32_;
    type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Fixed32Rules& FieldRules::fixed32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.fixed32)
  return has_fixed32()
      ? *type_.fixed32_
      : *reinterpret_cast< ::validate::Fixed32Rules*>(&::validate::_Fixed32Rules_default_instance_);
}
inline ::validate::Fixed32Rules* FieldRules::mutable_fixed32() {
  if (!has_fixed32()) {
    clear_type();
    set_has_fixed32();
    type_.fixed32_ = CreateMaybeMessage< ::validate::Fixed32Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.fixed32)
  return type_.fixed32_;
}

// optional .validate.Fixed64Rules fixed64 = 10;
inline bool FieldRules::has_fixed64() const {
  return type_case() == kFixed64;
}
inline void FieldRules::set_has_fixed64() {
  _oneof_case_[0] = kFixed64;
}
inline void FieldRules::clear_fixed64() {
  if (has_fixed64()) {
    delete type_.fixed64_;
    clear_has_type();
  }
}
inline ::validate::Fixed64Rules* FieldRules::release_fixed64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.fixed64)
  if (has_fixed64()) {
    clear_has_type();
      ::validate::Fixed64Rules* temp = type_.fixed64_;
    type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Fixed64Rules& FieldRules::fixed64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.fixed64)
  return has_fixed64()
      ? *type_.fixed64_
      : *reinterpret_cast< ::validate::Fixed64Rules*>(&::validate::_Fixed64Rules_default_instance_);
}
inline ::validate::Fixed64Rules* FieldRules::mutable_fixed64() {
  if (!has_fixed64()) {
    clear_type();
    set_has_fixed64();
    type_.fixed64_ = CreateMaybeMessage< ::validate::Fixed64Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.fixed64)
  return type_.fixed64_;
}

// optional .validate.SFixed32Rules sfixed32 = 11;
inline bool FieldRules::has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline void FieldRules::set_has_sfixed32() {
  _oneof_case_[0] = kSfixed32;
}
inline void FieldRules::clear_sfixed32() {
  if (has_sfixed32()) {
    delete type_.sfixed32_;
    clear_has_type();
  }
}
inline ::validate::SFixed32Rules* FieldRules::release_sfixed32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sfixed32)
  if (has_sfixed32()) {
    clear_has_type();
      ::validate::SFixed32Rules* temp = type_.sfixed32_;
    type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SFixed32Rules& FieldRules::sfixed32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sfixed32)
  return has_sfixed32()
      ? *type_.sfixed32_
      : *reinterpret_cast< ::validate::SFixed32Rules*>(&::validate::_SFixed32Rules_default_instance_);
}
inline ::validate::SFixed32Rules* FieldRules::mutable_sfixed32() {
  if (!has_sfixed32()) {
    clear_type();
    set_has_sfixed32();
    type_.sfixed32_ = CreateMaybeMessage< ::validate::SFixed32Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sfixed32)
  return type_.sfixed32_;
}

// optional .validate.SFixed64Rules sfixed64 = 12;
inline bool FieldRules::has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline void FieldRules::set_has_sfixed64() {
  _oneof_case_[0] = kSfixed64;
}
inline void FieldRules::clear_sfixed64() {
  if (has_sfixed64()) {
    delete type_.sfixed64_;
    clear_has_type();
  }
}
inline ::validate::SFixed64Rules* FieldRules::release_sfixed64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sfixed64)
  if (has_sfixed64()) {
    clear_has_type();
      ::validate::SFixed64Rules* temp = type_.sfixed64_;
    type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SFixed64Rules& FieldRules::sfixed64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sfixed64)
  return has_sfixed64()
      ? *type_.sfixed64_
      : *reinterpret_cast< ::validate::SFixed64Rules*>(&::validate::_SFixed64Rules_default_instance_);
}
inline ::validate::SFixed64Rules* FieldRules::mutable_sfixed64() {
  if (!has_sfixed64()) {
    clear_type();
    set_has_sfixed64();
    type_.sfixed64_ = CreateMaybeMessage< ::validate::SFixed64Rules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sfixed64)
  return type_.sfixed64_;
}

// optional .validate.BoolRules bool = 13;
inline bool FieldRules::has_bool_() const {
  return type_case() == kBool;
}
inline void FieldRules::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void FieldRules::clear_bool_() {
  if (has_bool_()) {
    delete type_.bool__;
    clear_has_type();
  }
}
inline ::validate::BoolRules* FieldRules::release_bool_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.bool)
  if (has_bool_()) {
    clear_has_type();
      ::validate::BoolRules* temp = type_.bool__;
    type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::BoolRules& FieldRules::bool_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.bool)
  return has_bool_()
      ? *type_.bool__
      : *reinterpret_cast< ::validate::BoolRules*>(&::validate::_BoolRules_default_instance_);
}
inline ::validate::BoolRules* FieldRules::mutable_bool_() {
  if (!has_bool_()) {
    clear_type();
    set_has_bool_();
    type_.bool__ = CreateMaybeMessage< ::validate::BoolRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.bool)
  return type_.bool__;
}

// optional .validate.StringRules string = 14;
inline bool FieldRules::has_string() const {
  return type_case() == kString;
}
inline void FieldRules::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void FieldRules::clear_string() {
  if (has_string()) {
    delete type_.string_;
    clear_has_type();
  }
}
inline ::validate::StringRules* FieldRules::release_string() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.string)
  if (has_string()) {
    clear_has_type();
      ::validate::StringRules* temp = type_.string_;
    type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::StringRules& FieldRules::string() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.string)
  return has_string()
      ? *type_.string_
      : *reinterpret_cast< ::validate::StringRules*>(&::validate::_StringRules_default_instance_);
}
inline ::validate::StringRules* FieldRules::mutable_string() {
  if (!has_string()) {
    clear_type();
    set_has_string();
    type_.string_ = CreateMaybeMessage< ::validate::StringRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.string)
  return type_.string_;
}

// optional .validate.BytesRules bytes = 15;
inline bool FieldRules::has_bytes() const {
  return type_case() == kBytes;
}
inline void FieldRules::set_has_bytes() {
  _oneof_case_[0] = kBytes;
}
inline void FieldRules::clear_bytes() {
  if (has_bytes()) {
    delete type_.bytes_;
    clear_has_type();
  }
}
inline ::validate::BytesRules* FieldRules::release_bytes() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.bytes)
  if (has_bytes()) {
    clear_has_type();
      ::validate::BytesRules* temp = type_.bytes_;
    type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::BytesRules& FieldRules::bytes() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.bytes)
  return has_bytes()
      ? *type_.bytes_
      : *reinterpret_cast< ::validate::BytesRules*>(&::validate::_BytesRules_default_instance_);
}
inline ::validate::BytesRules* FieldRules::mutable_bytes() {
  if (!has_bytes()) {
    clear_type();
    set_has_bytes();
    type_.bytes_ = CreateMaybeMessage< ::validate::BytesRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.bytes)
  return type_.bytes_;
}

// optional .validate.EnumRules enum = 16;
inline bool FieldRules::has_enum_() const {
  return type_case() == kEnum;
}
inline void FieldRules::set_has_enum_() {
  _oneof_case_[0] = kEnum;
}
inline void FieldRules::clear_enum_() {
  if (has_enum_()) {
    delete type_.enum__;
    clear_has_type();
  }
}
inline ::validate::EnumRules* FieldRules::release_enum_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.enum)
  if (has_enum_()) {
    clear_has_type();
      ::validate::EnumRules* temp = type_.enum__;
    type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::EnumRules& FieldRules::enum_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.enum)
  return has_enum_()
      ? *type_.enum__
      : *reinterpret_cast< ::validate::EnumRules*>(&::validate::_EnumRules_default_instance_);
}
inline ::validate::EnumRules* FieldRules::mutable_enum_() {
  if (!has_enum_()) {
    clear_type();
    set_has_enum_();
    type_.enum__ = CreateMaybeMessage< ::validate::EnumRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.enum)
  return type_.enum__;
}

// optional .validate.MessageRules message = 17;
inline bool FieldRules::has_message() const {
  return type_case() == kMessage;
}
inline void FieldRules::set_has_message() {
  _oneof_case_[0] = kMessage;
}
inline void FieldRules::clear_message() {
  if (has_message()) {
    delete type_.message_;
    clear_has_type();
  }
}
inline ::validate::MessageRules* FieldRules::release_message() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.message)
  if (has_message()) {
    clear_has_type();
      ::validate::MessageRules* temp = type_.message_;
    type_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::MessageRules& FieldRules::message() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.message)
  return has_message()
      ? *type_.message_
      : *reinterpret_cast< ::validate::MessageRules*>(&::validate::_MessageRules_default_instance_);
}
inline ::validate::MessageRules* FieldRules::mutable_message() {
  if (!has_message()) {
    clear_type();
    set_has_message();
    type_.message_ = CreateMaybeMessage< ::validate::MessageRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.message)
  return type_.message_;
}

// optional .validate.RepeatedRules repeated = 18;
inline bool FieldRules::has_repeated() const {
  return type_case() == kRepeated;
}
inline void FieldRules::set_has_repeated() {
  _oneof_case_[0] = kRepeated;
}
inline void FieldRules::clear_repeated() {
  if (has_repeated()) {
    delete type_.repeated_;
    clear_has_type();
  }
}
inline ::validate::RepeatedRules* FieldRules::release_repeated() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.repeated)
  if (has_repeated()) {
    clear_has_type();
      ::validate::RepeatedRules* temp = type_.repeated_;
    type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::RepeatedRules& FieldRules::repeated() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.repeated)
  return has_repeated()
      ? *type_.repeated_
      : *reinterpret_cast< ::validate::RepeatedRules*>(&::validate::_RepeatedRules_default_instance_);
}
inline ::validate::RepeatedRules* FieldRules::mutable_repeated() {
  if (!has_repeated()) {
    clear_type();
    set_has_repeated();
    type_.repeated_ = CreateMaybeMessage< ::validate::RepeatedRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.repeated)
  return type_.repeated_;
}

// optional .validate.MapRules map = 19;
inline bool FieldRules::has_map() const {
  return type_case() == kMap;
}
inline void FieldRules::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void FieldRules::clear_map() {
  if (has_map()) {
    delete type_.map_;
    clear_has_type();
  }
}
inline ::validate::MapRules* FieldRules::release_map() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.map)
  if (has_map()) {
    clear_has_type();
      ::validate::MapRules* temp = type_.map_;
    type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::MapRules& FieldRules::map() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.map)
  return has_map()
      ? *type_.map_
      : *reinterpret_cast< ::validate::MapRules*>(&::validate::_MapRules_default_instance_);
}
inline ::validate::MapRules* FieldRules::mutable_map() {
  if (!has_map()) {
    clear_type();
    set_has_map();
    type_.map_ = CreateMaybeMessage< ::validate::MapRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.map)
  return type_.map_;
}

// optional .validate.AnyRules any = 20;
inline bool FieldRules::has_any() const {
  return type_case() == kAny;
}
inline void FieldRules::set_has_any() {
  _oneof_case_[0] = kAny;
}
inline void FieldRules::clear_any() {
  if (has_any()) {
    delete type_.any_;
    clear_has_type();
  }
}
inline ::validate::AnyRules* FieldRules::release_any() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.any)
  if (has_any()) {
    clear_has_type();
      ::validate::AnyRules* temp = type_.any_;
    type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::AnyRules& FieldRules::any() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.any)
  return has_any()
      ? *type_.any_
      : *reinterpret_cast< ::validate::AnyRules*>(&::validate::_AnyRules_default_instance_);
}
inline ::validate::AnyRules* FieldRules::mutable_any() {
  if (!has_any()) {
    clear_type();
    set_has_any();
    type_.any_ = CreateMaybeMessage< ::validate::AnyRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.any)
  return type_.any_;
}

// optional .validate.DurationRules duration = 21;
inline bool FieldRules::has_duration() const {
  return type_case() == kDuration;
}
inline void FieldRules::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline void FieldRules::clear_duration() {
  if (has_duration()) {
    delete type_.duration_;
    clear_has_type();
  }
}
inline ::validate::DurationRules* FieldRules::release_duration() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.duration)
  if (has_duration()) {
    clear_has_type();
      ::validate::DurationRules* temp = type_.duration_;
    type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::DurationRules& FieldRules::duration() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.duration)
  return has_duration()
      ? *type_.duration_
      : *reinterpret_cast< ::validate::DurationRules*>(&::validate::_DurationRules_default_instance_);
}
inline ::validate::DurationRules* FieldRules::mutable_duration() {
  if (!has_duration()) {
    clear_type();
    set_has_duration();
    type_.duration_ = CreateMaybeMessage< ::validate::DurationRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.duration)
  return type_.duration_;
}

// optional .validate.TimestampRules timestamp = 22;
inline bool FieldRules::has_timestamp() const {
  return type_case() == kTimestamp;
}
inline void FieldRules::set_has_timestamp() {
  _oneof_case_[0] = kTimestamp;
}
inline void FieldRules::clear_timestamp() {
  if (has_timestamp()) {
    delete type_.timestamp_;
    clear_has_type();
  }
}
inline ::validate::TimestampRules* FieldRules::release_timestamp() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.timestamp)
  if (has_timestamp()) {
    clear_has_type();
      ::validate::TimestampRules* temp = type_.timestamp_;
    type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::TimestampRules& FieldRules::timestamp() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.timestamp)
  return has_timestamp()
      ? *type_.timestamp_
      : *reinterpret_cast< ::validate::TimestampRules*>(&::validate::_TimestampRules_default_instance_);
}
inline ::validate::TimestampRules* FieldRules::mutable_timestamp() {
  if (!has_timestamp()) {
    clear_type();
    set_has_timestamp();
    type_.timestamp_ = CreateMaybeMessage< ::validate::TimestampRules >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.timestamp)
  return type_.timestamp_;
}

inline bool FieldRules::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void FieldRules::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline FieldRules::TypeCase FieldRules::type_case() const {
  return FieldRules::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FloatRules

// optional float const = 1;
inline bool FloatRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatRules::clear_const_() {
  const__ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float FloatRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.const)
  return const__;
}
inline void FloatRules::set_const_(float value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.const)
}

// optional float lt = 2;
inline bool FloatRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatRules::clear_lt() {
  lt_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float FloatRules::lt() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.lt)
  return lt_;
}
inline void FloatRules::set_lt(float value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.lt)
}

// optional float lte = 3;
inline bool FloatRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloatRules::clear_lte() {
  lte_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float FloatRules::lte() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.lte)
  return lte_;
}
inline void FloatRules::set_lte(float value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.lte)
}

// optional float gt = 4;
inline bool FloatRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FloatRules::clear_gt() {
  gt_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float FloatRules::gt() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.gt)
  return gt_;
}
inline void FloatRules::set_gt(float value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.gt)
}

// optional float gte = 5;
inline bool FloatRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FloatRules::clear_gte() {
  gte_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float FloatRules::gte() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.gte)
  return gte_;
}
inline void FloatRules::set_gte(float value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.gte)
}

// repeated float in = 6;
inline int FloatRules::in_size() const {
  return in_.size();
}
inline void FloatRules::clear_in() {
  in_.Clear();
}
inline float FloatRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.in)
  return in_.Get(index);
}
inline void FloatRules::set_in(int index, float value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.FloatRules.in)
}
inline void FloatRules::add_in(float value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.FloatRules.in)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatRules::in() const {
  // @@protoc_insertion_point(field_list:validate.FloatRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.FloatRules.in)
  return &in_;
}

// repeated float not_in = 7;
inline int FloatRules::not_in_size() const {
  return not_in_.size();
}
inline void FloatRules::clear_not_in() {
  not_in_.Clear();
}
inline float FloatRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.not_in)
  return not_in_.Get(index);
}
inline void FloatRules::set_not_in(int index, float value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.FloatRules.not_in)
}
inline void FloatRules::add_not_in(float value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.FloatRules.not_in)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.FloatRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.FloatRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// DoubleRules

// optional double const = 1;
inline bool DoubleRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleRules::clear_const_() {
  const__ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DoubleRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.const)
  return const__;
}
inline void DoubleRules::set_const_(double value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.const)
}

// optional double lt = 2;
inline bool DoubleRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleRules::clear_lt() {
  lt_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double DoubleRules::lt() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.lt)
  return lt_;
}
inline void DoubleRules::set_lt(double value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.lt)
}

// optional double lte = 3;
inline bool DoubleRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DoubleRules::clear_lte() {
  lte_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double DoubleRules::lte() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.lte)
  return lte_;
}
inline void DoubleRules::set_lte(double value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.lte)
}

// optional double gt = 4;
inline bool DoubleRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DoubleRules::clear_gt() {
  gt_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double DoubleRules::gt() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.gt)
  return gt_;
}
inline void DoubleRules::set_gt(double value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.gt)
}

// optional double gte = 5;
inline bool DoubleRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DoubleRules::clear_gte() {
  gte_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double DoubleRules::gte() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.gte)
  return gte_;
}
inline void DoubleRules::set_gte(double value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.gte)
}

// repeated double in = 6;
inline int DoubleRules::in_size() const {
  return in_.size();
}
inline void DoubleRules::clear_in() {
  in_.Clear();
}
inline double DoubleRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.in)
  return in_.Get(index);
}
inline void DoubleRules::set_in(int index, double value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.DoubleRules.in)
}
inline void DoubleRules::add_in(double value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.DoubleRules.in)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleRules::in() const {
  // @@protoc_insertion_point(field_list:validate.DoubleRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DoubleRules.in)
  return &in_;
}

// repeated double not_in = 7;
inline int DoubleRules::not_in_size() const {
  return not_in_.size();
}
inline void DoubleRules::clear_not_in() {
  not_in_.Clear();
}
inline double DoubleRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.not_in)
  return not_in_.Get(index);
}
inline void DoubleRules::set_not_in(int index, double value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.DoubleRules.not_in)
}
inline void DoubleRules::add_not_in(double value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.DoubleRules.not_in)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.DoubleRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DoubleRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Int32Rules

// optional int32 const = 1;
inline bool Int32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int32Rules::clear_const_() {
  const__ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 Int32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.const)
  return const__;
}
inline void Int32Rules::set_const_(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.const)
}

// optional int32 lt = 2;
inline bool Int32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Int32Rules::clear_lt() {
  lt_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Int32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.lt)
  return lt_;
}
inline void Int32Rules::set_lt(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.lt)
}

// optional int32 lte = 3;
inline bool Int32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Int32Rules::clear_lte() {
  lte_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 Int32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.lte)
  return lte_;
}
inline void Int32Rules::set_lte(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.lte)
}

// optional int32 gt = 4;
inline bool Int32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Int32Rules::clear_gt() {
  gt_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 Int32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.gt)
  return gt_;
}
inline void Int32Rules::set_gt(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.gt)
}

// optional int32 gte = 5;
inline bool Int32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Int32Rules::clear_gte() {
  gte_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int32 Int32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.gte)
  return gte_;
}
inline void Int32Rules::set_gte(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.gte)
}

// repeated int32 in = 6;
inline int Int32Rules::in_size() const {
  return in_.size();
}
inline void Int32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 Int32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.in)
  return in_.Get(index);
}
inline void Int32Rules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int32Rules.in)
}
inline void Int32Rules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Int32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int32Rules.in)
  return &in_;
}

// repeated int32 not_in = 7;
inline int Int32Rules::not_in_size() const {
  return not_in_.size();
}
inline void Int32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 Int32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.not_in)
  return not_in_.Get(index);
}
inline void Int32Rules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int32Rules.not_in)
}
inline void Int32Rules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Int32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Int64Rules

// optional int64 const = 1;
inline bool Int64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int64Rules::clear_const_() {
  const__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 Int64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.const)
  return const__;
}
inline void Int64Rules::set_const_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.const)
}

// optional int64 lt = 2;
inline bool Int64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Int64Rules::clear_lt() {
  lt_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 Int64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.lt)
  return lt_;
}
inline void Int64Rules::set_lt(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.lt)
}

// optional int64 lte = 3;
inline bool Int64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Int64Rules::clear_lte() {
  lte_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 Int64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.lte)
  return lte_;
}
inline void Int64Rules::set_lte(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.lte)
}

// optional int64 gt = 4;
inline bool Int64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Int64Rules::clear_gt() {
  gt_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int64 Int64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.gt)
  return gt_;
}
inline void Int64Rules::set_gt(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.gt)
}

// optional int64 gte = 5;
inline bool Int64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Int64Rules::clear_gte() {
  gte_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int64 Int64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.gte)
  return gte_;
}
inline void Int64Rules::set_gte(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.gte)
}

// repeated int64 in = 6;
inline int Int64Rules::in_size() const {
  return in_.size();
}
inline void Int64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 Int64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.in)
  return in_.Get(index);
}
inline void Int64Rules::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int64Rules.in)
}
inline void Int64Rules::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Int64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int64Rules.in)
  return &in_;
}

// repeated int64 not_in = 7;
inline int Int64Rules::not_in_size() const {
  return not_in_.size();
}
inline void Int64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 Int64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.not_in)
  return not_in_.Get(index);
}
inline void Int64Rules::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int64Rules.not_in)
}
inline void Int64Rules::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Int64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// UInt32Rules

// optional uint32 const = 1;
inline bool UInt32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UInt32Rules::clear_const_() {
  const__ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 UInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.const)
  return const__;
}
inline void UInt32Rules::set_const_(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.const)
}

// optional uint32 lt = 2;
inline bool UInt32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UInt32Rules::clear_lt() {
  lt_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 UInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.lt)
  return lt_;
}
inline void UInt32Rules::set_lt(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.lt)
}

// optional uint32 lte = 3;
inline bool UInt32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UInt32Rules::clear_lte() {
  lte_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 UInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.lte)
  return lte_;
}
inline void UInt32Rules::set_lte(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.lte)
}

// optional uint32 gt = 4;
inline bool UInt32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UInt32Rules::clear_gt() {
  gt_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 UInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.gt)
  return gt_;
}
inline void UInt32Rules::set_gt(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.gt)
}

// optional uint32 gte = 5;
inline bool UInt32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UInt32Rules::clear_gte() {
  gte_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 UInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.gte)
  return gte_;
}
inline void UInt32Rules::set_gte(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.gte)
}

// repeated uint32 in = 6;
inline int UInt32Rules::in_size() const {
  return in_.size();
}
inline void UInt32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint32 UInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.in)
  return in_.Get(index);
}
inline void UInt32Rules::set_in(int index, ::google::protobuf::uint32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.in)
}
inline void UInt32Rules::add_in(::google::protobuf::uint32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UInt32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.UInt32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UInt32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt32Rules.in)
  return &in_;
}

// repeated uint32 not_in = 7;
inline int UInt32Rules::not_in_size() const {
  return not_in_.size();
}
inline void UInt32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint32 UInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.not_in)
  return not_in_.Get(index);
}
inline void UInt32Rules::set_not_in(int index, ::google::protobuf::uint32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.not_in)
}
inline void UInt32Rules::add_not_in(::google::protobuf::uint32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UInt32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.UInt32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UInt32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// UInt64Rules

// optional uint64 const = 1;
inline bool UInt64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UInt64Rules::clear_const_() {
  const__ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 UInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.const)
  return const__;
}
inline void UInt64Rules::set_const_(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.const)
}

// optional uint64 lt = 2;
inline bool UInt64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UInt64Rules::clear_lt() {
  lt_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 UInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.lt)
  return lt_;
}
inline void UInt64Rules::set_lt(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.lt)
}

// optional uint64 lte = 3;
inline bool UInt64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UInt64Rules::clear_lte() {
  lte_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 UInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.lte)
  return lte_;
}
inline void UInt64Rules::set_lte(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.lte)
}

// optional uint64 gt = 4;
inline bool UInt64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UInt64Rules::clear_gt() {
  gt_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 UInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.gt)
  return gt_;
}
inline void UInt64Rules::set_gt(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.gt)
}

// optional uint64 gte = 5;
inline bool UInt64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UInt64Rules::clear_gte() {
  gte_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 UInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.gte)
  return gte_;
}
inline void UInt64Rules::set_gte(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.gte)
}

// repeated uint64 in = 6;
inline int UInt64Rules::in_size() const {
  return in_.size();
}
inline void UInt64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint64 UInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.in)
  return in_.Get(index);
}
inline void UInt64Rules::set_in(int index, ::google::protobuf::uint64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.in)
}
inline void UInt64Rules::add_in(::google::protobuf::uint64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.UInt64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt64Rules.in)
  return &in_;
}

// repeated uint64 not_in = 7;
inline int UInt64Rules::not_in_size() const {
  return not_in_.size();
}
inline void UInt64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint64 UInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.not_in)
  return not_in_.Get(index);
}
inline void UInt64Rules::set_not_in(int index, ::google::protobuf::uint64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.not_in)
}
inline void UInt64Rules::add_not_in(::google::protobuf::uint64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.UInt64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SInt32Rules

// optional sint32 const = 1;
inline bool SInt32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SInt32Rules::clear_const_() {
  const__ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 SInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.const)
  return const__;
}
inline void SInt32Rules::set_const_(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.const)
}

// optional sint32 lt = 2;
inline bool SInt32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SInt32Rules::clear_lt() {
  lt_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 SInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.lt)
  return lt_;
}
inline void SInt32Rules::set_lt(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.lt)
}

// optional sint32 lte = 3;
inline bool SInt32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SInt32Rules::clear_lte() {
  lte_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 SInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.lte)
  return lte_;
}
inline void SInt32Rules::set_lte(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.lte)
}

// optional sint32 gt = 4;
inline bool SInt32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SInt32Rules::clear_gt() {
  gt_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 SInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.gt)
  return gt_;
}
inline void SInt32Rules::set_gt(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.gt)
}

// optional sint32 gte = 5;
inline bool SInt32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SInt32Rules::clear_gte() {
  gte_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int32 SInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.gte)
  return gte_;
}
inline void SInt32Rules::set_gte(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.gte)
}

// repeated sint32 in = 6;
inline int SInt32Rules::in_size() const {
  return in_.size();
}
inline void SInt32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 SInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.in)
  return in_.Get(index);
}
inline void SInt32Rules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.in)
}
inline void SInt32Rules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SInt32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SInt32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SInt32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt32Rules.in)
  return &in_;
}

// repeated sint32 not_in = 7;
inline int SInt32Rules::not_in_size() const {
  return not_in_.size();
}
inline void SInt32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 SInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.not_in)
  return not_in_.Get(index);
}
inline void SInt32Rules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.not_in)
}
inline void SInt32Rules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SInt32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SInt32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SInt32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SInt64Rules

// optional sint64 const = 1;
inline bool SInt64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SInt64Rules::clear_const_() {
  const__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 SInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.const)
  return const__;
}
inline void SInt64Rules::set_const_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.const)
}

// optional sint64 lt = 2;
inline bool SInt64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SInt64Rules::clear_lt() {
  lt_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 SInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.lt)
  return lt_;
}
inline void SInt64Rules::set_lt(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.lt)
}

// optional sint64 lte = 3;
inline bool SInt64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SInt64Rules::clear_lte() {
  lte_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 SInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.lte)
  return lte_;
}
inline void SInt64Rules::set_lte(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.lte)
}

// optional sint64 gt = 4;
inline bool SInt64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SInt64Rules::clear_gt() {
  gt_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int64 SInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.gt)
  return gt_;
}
inline void SInt64Rules::set_gt(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.gt)
}

// optional sint64 gte = 5;
inline bool SInt64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SInt64Rules::clear_gte() {
  gte_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int64 SInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.gte)
  return gte_;
}
inline void SInt64Rules::set_gte(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.gte)
}

// repeated sint64 in = 6;
inline int SInt64Rules::in_size() const {
  return in_.size();
}
inline void SInt64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 SInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.in)
  return in_.Get(index);
}
inline void SInt64Rules::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.in)
}
inline void SInt64Rules::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SInt64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SInt64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SInt64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt64Rules.in)
  return &in_;
}

// repeated sint64 not_in = 7;
inline int SInt64Rules::not_in_size() const {
  return not_in_.size();
}
inline void SInt64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 SInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.not_in)
  return not_in_.Get(index);
}
inline void SInt64Rules::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.not_in)
}
inline void SInt64Rules::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SInt64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SInt64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SInt64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Fixed32Rules

// optional fixed32 const = 1;
inline bool Fixed32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fixed32Rules::clear_const_() {
  const__ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 Fixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.const)
  return const__;
}
inline void Fixed32Rules::set_const_(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.const)
}

// optional fixed32 lt = 2;
inline bool Fixed32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fixed32Rules::clear_lt() {
  lt_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 Fixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.lt)
  return lt_;
}
inline void Fixed32Rules::set_lt(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.lt)
}

// optional fixed32 lte = 3;
inline bool Fixed32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fixed32Rules::clear_lte() {
  lte_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 Fixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.lte)
  return lte_;
}
inline void Fixed32Rules::set_lte(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.lte)
}

// optional fixed32 gt = 4;
inline bool Fixed32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fixed32Rules::clear_gt() {
  gt_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 Fixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.gt)
  return gt_;
}
inline void Fixed32Rules::set_gt(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.gt)
}

// optional fixed32 gte = 5;
inline bool Fixed32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fixed32Rules::clear_gte() {
  gte_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 Fixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.gte)
  return gte_;
}
inline void Fixed32Rules::set_gte(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.gte)
}

// repeated fixed32 in = 6;
inline int Fixed32Rules::in_size() const {
  return in_.size();
}
inline void Fixed32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint32 Fixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.in)
  return in_.Get(index);
}
inline void Fixed32Rules::set_in(int index, ::google::protobuf::uint32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.in)
}
inline void Fixed32Rules::add_in(::google::protobuf::uint32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Fixed32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Fixed32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed32Rules.in)
  return &in_;
}

// repeated fixed32 not_in = 7;
inline int Fixed32Rules::not_in_size() const {
  return not_in_.size();
}
inline void Fixed32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint32 Fixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.not_in)
  return not_in_.Get(index);
}
inline void Fixed32Rules::set_not_in(int index, ::google::protobuf::uint32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.not_in)
}
inline void Fixed32Rules::add_not_in(::google::protobuf::uint32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Fixed32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Fixed32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Fixed64Rules

// optional fixed64 const = 1;
inline bool Fixed64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fixed64Rules::clear_const_() {
  const__ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 Fixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.const)
  return const__;
}
inline void Fixed64Rules::set_const_(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.const)
}

// optional fixed64 lt = 2;
inline bool Fixed64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fixed64Rules::clear_lt() {
  lt_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 Fixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.lt)
  return lt_;
}
inline void Fixed64Rules::set_lt(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.lt)
}

// optional fixed64 lte = 3;
inline bool Fixed64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fixed64Rules::clear_lte() {
  lte_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 Fixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.lte)
  return lte_;
}
inline void Fixed64Rules::set_lte(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.lte)
}

// optional fixed64 gt = 4;
inline bool Fixed64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fixed64Rules::clear_gt() {
  gt_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 Fixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.gt)
  return gt_;
}
inline void Fixed64Rules::set_gt(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.gt)
}

// optional fixed64 gte = 5;
inline bool Fixed64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fixed64Rules::clear_gte() {
  gte_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 Fixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.gte)
  return gte_;
}
inline void Fixed64Rules::set_gte(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.gte)
}

// repeated fixed64 in = 6;
inline int Fixed64Rules::in_size() const {
  return in_.size();
}
inline void Fixed64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint64 Fixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.in)
  return in_.Get(index);
}
inline void Fixed64Rules::set_in(int index, ::google::protobuf::uint64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.in)
}
inline void Fixed64Rules::add_in(::google::protobuf::uint64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Fixed64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Fixed64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed64Rules.in)
  return &in_;
}

// repeated fixed64 not_in = 7;
inline int Fixed64Rules::not_in_size() const {
  return not_in_.size();
}
inline void Fixed64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint64 Fixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.not_in)
  return not_in_.Get(index);
}
inline void Fixed64Rules::set_not_in(int index, ::google::protobuf::uint64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.not_in)
}
inline void Fixed64Rules::add_not_in(::google::protobuf::uint64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Fixed64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Fixed64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SFixed32Rules

// optional sfixed32 const = 1;
inline bool SFixed32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SFixed32Rules::clear_const_() {
  const__ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 SFixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.const)
  return const__;
}
inline void SFixed32Rules::set_const_(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.const)
}

// optional sfixed32 lt = 2;
inline bool SFixed32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SFixed32Rules::clear_lt() {
  lt_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 SFixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.lt)
  return lt_;
}
inline void SFixed32Rules::set_lt(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.lt)
}

// optional sfixed32 lte = 3;
inline bool SFixed32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SFixed32Rules::clear_lte() {
  lte_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 SFixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.lte)
  return lte_;
}
inline void SFixed32Rules::set_lte(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.lte)
}

// optional sfixed32 gt = 4;
inline bool SFixed32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SFixed32Rules::clear_gt() {
  gt_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 SFixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.gt)
  return gt_;
}
inline void SFixed32Rules::set_gt(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.gt)
}

// optional sfixed32 gte = 5;
inline bool SFixed32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SFixed32Rules::clear_gte() {
  gte_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int32 SFixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.gte)
  return gte_;
}
inline void SFixed32Rules::set_gte(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.gte)
}

// repeated sfixed32 in = 6;
inline int SFixed32Rules::in_size() const {
  return in_.size();
}
inline void SFixed32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 SFixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.in)
  return in_.Get(index);
}
inline void SFixed32Rules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.in)
}
inline void SFixed32Rules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SFixed32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SFixed32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed32Rules.in)
  return &in_;
}

// repeated sfixed32 not_in = 7;
inline int SFixed32Rules::not_in_size() const {
  return not_in_.size();
}
inline void SFixed32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 SFixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.not_in)
  return not_in_.Get(index);
}
inline void SFixed32Rules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.not_in)
}
inline void SFixed32Rules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SFixed32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SFixed32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SFixed64Rules

// optional sfixed64 const = 1;
inline bool SFixed64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SFixed64Rules::clear_const_() {
  const__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 SFixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.const)
  return const__;
}
inline void SFixed64Rules::set_const_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.const)
}

// optional sfixed64 lt = 2;
inline bool SFixed64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SFixed64Rules::clear_lt() {
  lt_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 SFixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.lt)
  return lt_;
}
inline void SFixed64Rules::set_lt(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.lt)
}

// optional sfixed64 lte = 3;
inline bool SFixed64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SFixed64Rules::clear_lte() {
  lte_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 SFixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.lte)
  return lte_;
}
inline void SFixed64Rules::set_lte(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.lte)
}

// optional sfixed64 gt = 4;
inline bool SFixed64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SFixed64Rules::clear_gt() {
  gt_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int64 SFixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.gt)
  return gt_;
}
inline void SFixed64Rules::set_gt(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.gt)
}

// optional sfixed64 gte = 5;
inline bool SFixed64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SFixed64Rules::clear_gte() {
  gte_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int64 SFixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.gte)
  return gte_;
}
inline void SFixed64Rules::set_gte(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.gte)
}

// repeated sfixed64 in = 6;
inline int SFixed64Rules::in_size() const {
  return in_.size();
}
inline void SFixed64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 SFixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.in)
  return in_.Get(index);
}
inline void SFixed64Rules::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.in)
}
inline void SFixed64Rules::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SFixed64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SFixed64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed64Rules.in)
  return &in_;
}

// repeated sfixed64 not_in = 7;
inline int SFixed64Rules::not_in_size() const {
  return not_in_.size();
}
inline void SFixed64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 SFixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.not_in)
  return not_in_.Get(index);
}
inline void SFixed64Rules::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.not_in)
}
inline void SFixed64Rules::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SFixed64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SFixed64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// BoolRules

// optional bool const = 1;
inline bool BoolRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoolRules::clear_const_() {
  const__ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BoolRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.BoolRules.const)
  return const__;
}
inline void BoolRules::set_const_(bool value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.BoolRules.const)
}

// -------------------------------------------------------------------

// StringRules

// optional string const = 1;
inline bool StringRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringRules::clear_const_() {
  const__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& StringRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.const)
  return const__.GetNoArena();
}
inline void StringRules::set_const_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.const)
}
#if LANG_CXX11
inline void StringRules::set_const_(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.const)
}
#endif
inline void StringRules::set_const_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.const)
}
inline void StringRules::set_const_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.const)
}
inline ::std::string* StringRules::mutable_const_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:validate.StringRules.const)
  return const__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.StringRules.const)
  if (!has_const_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return const__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_const_(::std::string* const_) {
  if (const_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  const__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), const_);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.const)
}

// optional uint64 len = 19;
inline bool StringRules::has_len() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StringRules::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint64 StringRules::len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.len)
  return len_;
}
inline void StringRules::set_len(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  len_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.len)
}

// optional uint64 min_len = 2;
inline bool StringRules::has_min_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StringRules::clear_min_len() {
  min_len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 StringRules::min_len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.min_len)
  return min_len_;
}
inline void StringRules::set_min_len(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  min_len_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.min_len)
}

// optional uint64 max_len = 3;
inline bool StringRules::has_max_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StringRules::clear_max_len() {
  max_len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 StringRules::max_len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.max_len)
  return max_len_;
}
inline void StringRules::set_max_len(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  max_len_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.max_len)
}

// optional uint64 len_bytes = 20;
inline bool StringRules::has_len_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StringRules::clear_len_bytes() {
  len_bytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint64 StringRules::len_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.len_bytes)
  return len_bytes_;
}
inline void StringRules::set_len_bytes(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  len_bytes_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.len_bytes)
}

// optional uint64 min_bytes = 4;
inline bool StringRules::has_min_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StringRules::clear_min_bytes() {
  min_bytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 StringRules::min_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.min_bytes)
  return min_bytes_;
}
inline void StringRules::set_min_bytes(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  min_bytes_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.min_bytes)
}

// optional uint64 max_bytes = 5;
inline bool StringRules::has_max_bytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StringRules::clear_max_bytes() {
  max_bytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint64 StringRules::max_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.max_bytes)
  return max_bytes_;
}
inline void StringRules::set_max_bytes(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  max_bytes_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.max_bytes)
}

// optional string pattern = 6;
inline bool StringRules::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringRules::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& StringRules::pattern() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.pattern)
  return pattern_.GetNoArena();
}
inline void StringRules::set_pattern(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.pattern)
}
#if LANG_CXX11
inline void StringRules::set_pattern(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.pattern)
}
#endif
inline void StringRules::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.pattern)
}
inline void StringRules::set_pattern(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.pattern)
}
inline ::std::string* StringRules::mutable_pattern() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:validate.StringRules.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_pattern() {
  // @@protoc_insertion_point(field_release:validate.StringRules.pattern)
  if (!has_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pattern_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_pattern(::std::string* pattern) {
  if (pattern != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.pattern)
}

// optional string prefix = 7;
inline bool StringRules::has_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StringRules::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& StringRules::prefix() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.prefix)
  return prefix_.GetNoArena();
}
inline void StringRules::set_prefix(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.prefix)
}
#if LANG_CXX11
inline void StringRules::set_prefix(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.prefix)
}
#endif
inline void StringRules::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.prefix)
}
inline void StringRules::set_prefix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.prefix)
}
inline ::std::string* StringRules::mutable_prefix() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:validate.StringRules.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_prefix() {
  // @@protoc_insertion_point(field_release:validate.StringRules.prefix)
  if (!has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return prefix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_prefix(::std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.prefix)
}

// optional string suffix = 8;
inline bool StringRules::has_suffix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StringRules::clear_suffix() {
  suffix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& StringRules::suffix() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.suffix)
  return suffix_.GetNoArena();
}
inline void StringRules::set_suffix(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.suffix)
}
#if LANG_CXX11
inline void StringRules::set_suffix(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.suffix)
}
#endif
inline void StringRules::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.suffix)
}
inline void StringRules::set_suffix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.suffix)
}
inline ::std::string* StringRules::mutable_suffix() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:validate.StringRules.suffix)
  return suffix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_suffix() {
  // @@protoc_insertion_point(field_release:validate.StringRules.suffix)
  if (!has_suffix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return suffix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_suffix(::std::string* suffix) {
  if (suffix != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  suffix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suffix);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.suffix)
}

// optional string contains = 9;
inline bool StringRules::has_contains() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StringRules::clear_contains() {
  contains_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& StringRules::contains() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.contains)
  return contains_.GetNoArena();
}
inline void StringRules::set_contains(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.contains)
}
#if LANG_CXX11
inline void StringRules::set_contains(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.contains)
}
#endif
inline void StringRules::set_contains(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.contains)
}
inline void StringRules::set_contains(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.contains)
}
inline ::std::string* StringRules::mutable_contains() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:validate.StringRules.contains)
  return contains_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_contains() {
  // @@protoc_insertion_point(field_release:validate.StringRules.contains)
  if (!has_contains()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return contains_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_contains(::std::string* contains) {
  if (contains != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  contains_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contains);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.contains)
}

// repeated string in = 10;
inline int StringRules::in_size() const {
  return in_.size();
}
inline void StringRules::clear_in() {
  in_.Clear();
}
inline const ::std::string& StringRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.StringRules.in)
  return in_.Get(index);
}
inline ::std::string* StringRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.StringRules.in)
  return in_.Mutable(index);
}
inline void StringRules::set_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.in)
  in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringRules::set_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.in)
  in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringRules::set_in(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.StringRules.in)
}
inline void StringRules::set_in(int index, const char* value, size_t size) {
  in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.in)
}
inline ::std::string* StringRules::add_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.StringRules.in)
  return in_.Add();
}
inline void StringRules::add_in(const ::std::string& value) {
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.StringRules.in)
}
#if LANG_CXX11
inline void StringRules::add_in(::std::string&& value) {
  in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.StringRules.in)
}
#endif
inline void StringRules::add_in(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.StringRules.in)
}
inline void StringRules::add_in(const char* value, size_t size) {
  in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.StringRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StringRules::in() const {
  // @@protoc_insertion_point(field_list:validate.StringRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
StringRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.StringRules.in)
  return &in_;
}

// repeated string not_in = 11;
inline int StringRules::not_in_size() const {
  return not_in_.size();
}
inline void StringRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::std::string& StringRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.StringRules.not_in)
  return not_in_.Get(index);
}
inline ::std::string* StringRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.StringRules.not_in)
  return not_in_.Mutable(index);
}
inline void StringRules::set_not_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.not_in)
  not_in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringRules::set_not_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.not_in)
  not_in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringRules::set_not_in(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, const char* value, size_t size) {
  not_in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.not_in)
}
inline ::std::string* StringRules::add_not_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.StringRules.not_in)
  return not_in_.Add();
}
inline void StringRules::add_not_in(const ::std::string& value) {
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.StringRules.not_in)
}
#if LANG_CXX11
inline void StringRules::add_not_in(::std::string&& value) {
  not_in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.StringRules.not_in)
}
#endif
inline void StringRules::add_not_in(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const char* value, size_t size) {
  not_in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.StringRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StringRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.StringRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
StringRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.StringRules.not_in)
  return &not_in_;
}

// optional bool email = 12;
inline bool StringRules::has_email() const {
  return well_known_case() == kEmail;
}
inline void StringRules::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void StringRules::clear_email() {
  if (has_email()) {
    well_known_.email_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::email() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.email)
  if (has_email()) {
    return well_known_.email_;
  }
  return false;
}
inline void StringRules::set_email(bool value) {
  if (!has_email()) {
    clear_well_known();
    set_has_email();
  }
  well_known_.email_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.email)
}

// optional bool hostname = 13;
inline bool StringRules::has_hostname() const {
  return well_known_case() == kHostname;
}
inline void StringRules::set_has_hostname() {
  _oneof_case_[0] = kHostname;
}
inline void StringRules::clear_hostname() {
  if (has_hostname()) {
    well_known_.hostname_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::hostname() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.hostname)
  if (has_hostname()) {
    return well_known_.hostname_;
  }
  return false;
}
inline void StringRules::set_hostname(bool value) {
  if (!has_hostname()) {
    clear_well_known();
    set_has_hostname();
  }
  well_known_.hostname_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.hostname)
}

// optional bool ip = 14;
inline bool StringRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void StringRules::set_has_ip() {
  _oneof_case_[0] = kIp;
}
inline void StringRules::clear_ip() {
  if (has_ip()) {
    well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ip)
  if (has_ip()) {
    return well_known_.ip_;
  }
  return false;
}
inline void StringRules::set_ip(bool value) {
  if (!has_ip()) {
    clear_well_known();
    set_has_ip();
  }
  well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ip)
}

// optional bool ipv4 = 15;
inline bool StringRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void StringRules::set_has_ipv4() {
  _oneof_case_[0] = kIpv4;
}
inline void StringRules::clear_ipv4() {
  if (has_ipv4()) {
    well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ipv4)
  if (has_ipv4()) {
    return well_known_.ipv4_;
  }
  return false;
}
inline void StringRules::set_ipv4(bool value) {
  if (!has_ipv4()) {
    clear_well_known();
    set_has_ipv4();
  }
  well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ipv4)
}

// optional bool ipv6 = 16;
inline bool StringRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void StringRules::set_has_ipv6() {
  _oneof_case_[0] = kIpv6;
}
inline void StringRules::clear_ipv6() {
  if (has_ipv6()) {
    well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ipv6)
  if (has_ipv6()) {
    return well_known_.ipv6_;
  }
  return false;
}
inline void StringRules::set_ipv6(bool value) {
  if (!has_ipv6()) {
    clear_well_known();
    set_has_ipv6();
  }
  well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ipv6)
}

// optional bool uri = 17;
inline bool StringRules::has_uri() const {
  return well_known_case() == kUri;
}
inline void StringRules::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void StringRules::clear_uri() {
  if (has_uri()) {
    well_known_.uri_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uri)
  if (has_uri()) {
    return well_known_.uri_;
  }
  return false;
}
inline void StringRules::set_uri(bool value) {
  if (!has_uri()) {
    clear_well_known();
    set_has_uri();
  }
  well_known_.uri_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uri)
}

// optional bool uri_ref = 18;
inline bool StringRules::has_uri_ref() const {
  return well_known_case() == kUriRef;
}
inline void StringRules::set_has_uri_ref() {
  _oneof_case_[0] = kUriRef;
}
inline void StringRules::clear_uri_ref() {
  if (has_uri_ref()) {
    well_known_.uri_ref_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri_ref() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uri_ref)
  if (has_uri_ref()) {
    return well_known_.uri_ref_;
  }
  return false;
}
inline void StringRules::set_uri_ref(bool value) {
  if (!has_uri_ref()) {
    clear_well_known();
    set_has_uri_ref();
  }
  well_known_.uri_ref_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uri_ref)
}

inline bool StringRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void StringRules::clear_has_well_known() {
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline StringRules::WellKnownCase StringRules::well_known_case() const {
  return StringRules::WellKnownCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BytesRules

// optional bytes const = 1;
inline bool BytesRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytesRules::clear_const_() {
  const__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BytesRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.const)
  return const__.GetNoArena();
}
inline void BytesRules::set_const_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.const)
}
#if LANG_CXX11
inline void BytesRules::set_const_(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.const)
}
#endif
inline void BytesRules::set_const_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.const)
}
inline void BytesRules::set_const_(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.const)
}
inline ::std::string* BytesRules::mutable_const_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.const)
  return const__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.const)
  if (!has_const_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return const__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_const_(::std::string* const_) {
  if (const_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  const__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), const_);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.const)
}

// optional uint64 len = 13;
inline bool BytesRules::has_len() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BytesRules::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 BytesRules::len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.len)
  return len_;
}
inline void BytesRules::set_len(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  len_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.len)
}

// optional uint64 min_len = 2;
inline bool BytesRules::has_min_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BytesRules::clear_min_len() {
  min_len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 BytesRules::min_len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.min_len)
  return min_len_;
}
inline void BytesRules::set_min_len(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  min_len_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.min_len)
}

// optional uint64 max_len = 3;
inline bool BytesRules::has_max_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BytesRules::clear_max_len() {
  max_len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 BytesRules::max_len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.max_len)
  return max_len_;
}
inline void BytesRules::set_max_len(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  max_len_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.max_len)
}

// optional string pattern = 4;
inline bool BytesRules::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytesRules::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BytesRules::pattern() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.pattern)
  return pattern_.GetNoArena();
}
inline void BytesRules::set_pattern(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.pattern)
}
#if LANG_CXX11
inline void BytesRules::set_pattern(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.pattern)
}
#endif
inline void BytesRules::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.pattern)
}
inline void BytesRules::set_pattern(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.pattern)
}
inline ::std::string* BytesRules::mutable_pattern() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_pattern() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.pattern)
  if (!has_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pattern_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_pattern(::std::string* pattern) {
  if (pattern != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.pattern)
}

// optional bytes prefix = 5;
inline bool BytesRules::has_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytesRules::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BytesRules::prefix() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.prefix)
  return prefix_.GetNoArena();
}
inline void BytesRules::set_prefix(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.prefix)
}
#if LANG_CXX11
inline void BytesRules::set_prefix(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.prefix)
}
#endif
inline void BytesRules::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.prefix)
}
inline void BytesRules::set_prefix(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.prefix)
}
inline ::std::string* BytesRules::mutable_prefix() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_prefix() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.prefix)
  if (!has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return prefix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_prefix(::std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.prefix)
}

// optional bytes suffix = 6;
inline bool BytesRules::has_suffix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BytesRules::clear_suffix() {
  suffix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& BytesRules::suffix() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.suffix)
  return suffix_.GetNoArena();
}
inline void BytesRules::set_suffix(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.suffix)
}
#if LANG_CXX11
inline void BytesRules::set_suffix(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.suffix)
}
#endif
inline void BytesRules::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.suffix)
}
inline void BytesRules::set_suffix(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.suffix)
}
inline ::std::string* BytesRules::mutable_suffix() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.suffix)
  return suffix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_suffix() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.suffix)
  if (!has_suffix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return suffix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_suffix(::std::string* suffix) {
  if (suffix != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  suffix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suffix);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.suffix)
}

// optional bytes contains = 7;
inline bool BytesRules::has_contains() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BytesRules::clear_contains() {
  contains_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& BytesRules::contains() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.contains)
  return contains_.GetNoArena();
}
inline void BytesRules::set_contains(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.contains)
}
#if LANG_CXX11
inline void BytesRules::set_contains(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.contains)
}
#endif
inline void BytesRules::set_contains(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.contains)
}
inline void BytesRules::set_contains(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.contains)
}
inline ::std::string* BytesRules::mutable_contains() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.contains)
  return contains_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_contains() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.contains)
  if (!has_contains()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return contains_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_contains(::std::string* contains) {
  if (contains != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  contains_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contains);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.contains)
}

// repeated bytes in = 8;
inline int BytesRules::in_size() const {
  return in_.size();
}
inline void BytesRules::clear_in() {
  in_.Clear();
}
inline const ::std::string& BytesRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.in)
  return in_.Get(index);
}
inline ::std::string* BytesRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.in)
  return in_.Mutable(index);
}
inline void BytesRules::set_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.in)
  in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytesRules::set_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.in)
  in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytesRules::set_in(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, const void* value, size_t size) {
  in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.in)
}
inline ::std::string* BytesRules::add_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.BytesRules.in)
  return in_.Add();
}
inline void BytesRules::add_in(const ::std::string& value) {
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.BytesRules.in)
}
#if LANG_CXX11
inline void BytesRules::add_in(::std::string&& value) {
  in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.BytesRules.in)
}
#endif
inline void BytesRules::add_in(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.BytesRules.in)
}
inline void BytesRules::add_in(const void* value, size_t size) {
  in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.BytesRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BytesRules::in() const {
  // @@protoc_insertion_point(field_list:validate.BytesRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
BytesRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.BytesRules.in)
  return &in_;
}

// repeated bytes not_in = 9;
inline int BytesRules::not_in_size() const {
  return not_in_.size();
}
inline void BytesRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::std::string& BytesRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.not_in)
  return not_in_.Get(index);
}
inline ::std::string* BytesRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.not_in)
  return not_in_.Mutable(index);
}
inline void BytesRules::set_not_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.not_in)
  not_in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytesRules::set_not_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.not_in)
  not_in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytesRules::set_not_in(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, const void* value, size_t size) {
  not_in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.not_in)
}
inline ::std::string* BytesRules::add_not_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.BytesRules.not_in)
  return not_in_.Add();
}
inline void BytesRules::add_not_in(const ::std::string& value) {
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.BytesRules.not_in)
}
#if LANG_CXX11
inline void BytesRules::add_not_in(::std::string&& value) {
  not_in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.BytesRules.not_in)
}
#endif
inline void BytesRules::add_not_in(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const void* value, size_t size) {
  not_in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.BytesRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BytesRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.BytesRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
BytesRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.BytesRules.not_in)
  return &not_in_;
}

// optional bool ip = 10;
inline bool BytesRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void BytesRules::set_has_ip() {
  _oneof_case_[0] = kIp;
}
inline void BytesRules::clear_ip() {
  if (has_ip()) {
    well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ip() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ip)
  if (has_ip()) {
    return well_known_.ip_;
  }
  return false;
}
inline void BytesRules::set_ip(bool value) {
  if (!has_ip()) {
    clear_well_known();
    set_has_ip();
  }
  well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ip)
}

// optional bool ipv4 = 11;
inline bool BytesRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void BytesRules::set_has_ipv4() {
  _oneof_case_[0] = kIpv4;
}
inline void BytesRules::clear_ipv4() {
  if (has_ipv4()) {
    well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv4() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ipv4)
  if (has_ipv4()) {
    return well_known_.ipv4_;
  }
  return false;
}
inline void BytesRules::set_ipv4(bool value) {
  if (!has_ipv4()) {
    clear_well_known();
    set_has_ipv4();
  }
  well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ipv4)
}

// optional bool ipv6 = 12;
inline bool BytesRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void BytesRules::set_has_ipv6() {
  _oneof_case_[0] = kIpv6;
}
inline void BytesRules::clear_ipv6() {
  if (has_ipv6()) {
    well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv6() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ipv6)
  if (has_ipv6()) {
    return well_known_.ipv6_;
  }
  return false;
}
inline void BytesRules::set_ipv6(bool value) {
  if (!has_ipv6()) {
    clear_well_known();
    set_has_ipv6();
  }
  well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ipv6)
}

inline bool BytesRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void BytesRules::clear_has_well_known() {
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline BytesRules::WellKnownCase BytesRules::well_known_case() const {
  return BytesRules::WellKnownCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnumRules

// optional int32 const = 1;
inline bool EnumRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumRules::clear_const_() {
  const__ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 EnumRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.const)
  return const__;
}
inline void EnumRules::set_const_(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.EnumRules.const)
}

// optional bool defined_only = 2;
inline bool EnumRules::has_defined_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumRules::clear_defined_only() {
  defined_only_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool EnumRules::defined_only() const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.defined_only)
  return defined_only_;
}
inline void EnumRules::set_defined_only(bool value) {
  _has_bits_[0] |= 0x00000002u;
  defined_only_ = value;
  // @@protoc_insertion_point(field_set:validate.EnumRules.defined_only)
}

// repeated int32 in = 3;
inline int EnumRules::in_size() const {
  return in_.size();
}
inline void EnumRules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 EnumRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.in)
  return in_.Get(index);
}
inline void EnumRules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.EnumRules.in)
}
inline void EnumRules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.EnumRules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EnumRules::in() const {
  // @@protoc_insertion_point(field_list:validate.EnumRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EnumRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.EnumRules.in)
  return &in_;
}

// repeated int32 not_in = 4;
inline int EnumRules::not_in_size() const {
  return not_in_.size();
}
inline void EnumRules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 EnumRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.not_in)
  return not_in_.Get(index);
}
inline void EnumRules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.EnumRules.not_in)
}
inline void EnumRules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.EnumRules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EnumRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.EnumRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EnumRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.EnumRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// MessageRules

// optional bool skip = 1;
inline bool MessageRules::has_skip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageRules::clear_skip() {
  skip_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MessageRules::skip() const {
  // @@protoc_insertion_point(field_get:validate.MessageRules.skip)
  return skip_;
}
inline void MessageRules::set_skip(bool value) {
  _has_bits_[0] |= 0x00000001u;
  skip_ = value;
  // @@protoc_insertion_point(field_set:validate.MessageRules.skip)
}

// optional bool required = 2;
inline bool MessageRules::has_required() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageRules::clear_required() {
  required_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MessageRules::required() const {
  // @@protoc_insertion_point(field_get:validate.MessageRules.required)
  return required_;
}
inline void MessageRules::set_required(bool value) {
  _has_bits_[0] |= 0x00000002u;
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.MessageRules.required)
}

// -------------------------------------------------------------------

// RepeatedRules

// optional uint64 min_items = 1;
inline bool RepeatedRules::has_min_items() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RepeatedRules::clear_min_items() {
  min_items_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 RepeatedRules::min_items() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.min_items)
  return min_items_;
}
inline void RepeatedRules::set_min_items(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  min_items_ = value;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.min_items)
}

// optional uint64 max_items = 2;
inline bool RepeatedRules::has_max_items() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RepeatedRules::clear_max_items() {
  max_items_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 RepeatedRules::max_items() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.max_items)
  return max_items_;
}
inline void RepeatedRules::set_max_items(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  max_items_ = value;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.max_items)
}

// optional bool unique = 3;
inline bool RepeatedRules::has_unique() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RepeatedRules::clear_unique() {
  unique_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RepeatedRules::unique() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.unique)
  return unique_;
}
inline void RepeatedRules::set_unique(bool value) {
  _has_bits_[0] |= 0x00000008u;
  unique_ = value;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.unique)
}

// optional .validate.FieldRules items = 4;
inline bool RepeatedRules::has_items() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RepeatedRules::clear_items() {
  if (items_ != nullptr) items_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::validate::FieldRules& RepeatedRules::items() const {
  const ::validate::FieldRules* p = items_;
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.items)
  return p != nullptr ? *p : *reinterpret_cast<const ::validate::FieldRules*>(
      &::validate::_FieldRules_default_instance_);
}
inline ::validate::FieldRules* RepeatedRules::release_items() {
  // @@protoc_insertion_point(field_release:validate.RepeatedRules.items)
  _has_bits_[0] &= ~0x00000001u;
  ::validate::FieldRules* temp = items_;
  items_ = nullptr;
  return temp;
}
inline ::validate::FieldRules* RepeatedRules::mutable_items() {
  _has_bits_[0] |= 0x00000001u;
  if (items_ == nullptr) {
    auto* p = CreateMaybeMessage<::validate::FieldRules>(GetArenaNoVirtual());
    items_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.RepeatedRules.items)
  return items_;
}
inline void RepeatedRules::set_allocated_items(::validate::FieldRules* items) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete items_;
  }
  if (items) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      items = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  items_ = items;
  // @@protoc_insertion_point(field_set_allocated:validate.RepeatedRules.items)
}

// -------------------------------------------------------------------

// MapRules

// optional uint64 min_pairs = 1;
inline bool MapRules::has_min_pairs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapRules::clear_min_pairs() {
  min_pairs_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 MapRules::min_pairs() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.min_pairs)
  return min_pairs_;
}
inline void MapRules::set_min_pairs(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  min_pairs_ = value;
  // @@protoc_insertion_point(field_set:validate.MapRules.min_pairs)
}

// optional uint64 max_pairs = 2;
inline bool MapRules::has_max_pairs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapRules::clear_max_pairs() {
  max_pairs_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 MapRules::max_pairs() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.max_pairs)
  return max_pairs_;
}
inline void MapRules::set_max_pairs(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  max_pairs_ = value;
  // @@protoc_insertion_point(field_set:validate.MapRules.max_pairs)
}

// optional bool no_sparse = 3;
inline bool MapRules::has_no_sparse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapRules::clear_no_sparse() {
  no_sparse_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool MapRules::no_sparse() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.no_sparse)
  return no_sparse_;
}
inline void MapRules::set_no_sparse(bool value) {
  _has_bits_[0] |= 0x00000010u;
  no_sparse_ = value;
  // @@protoc_insertion_point(field_set:validate.MapRules.no_sparse)
}

// optional .validate.FieldRules keys = 4;
inline bool MapRules::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapRules::clear_keys() {
  if (keys_ != nullptr) keys_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::validate::FieldRules& MapRules::keys() const {
  const ::validate::FieldRules* p = keys_;
  // @@protoc_insertion_point(field_get:validate.MapRules.keys)
  return p != nullptr ? *p : *reinterpret_cast<const ::validate::FieldRules*>(
      &::validate::_FieldRules_default_instance_);
}
inline ::validate::FieldRules* MapRules::release_keys() {
  // @@protoc_insertion_point(field_release:validate.MapRules.keys)
  _has_bits_[0] &= ~0x00000001u;
  ::validate::FieldRules* temp = keys_;
  keys_ = nullptr;
  return temp;
}
inline ::validate::FieldRules* MapRules::mutable_keys() {
  _has_bits_[0] |= 0x00000001u;
  if (keys_ == nullptr) {
    auto* p = CreateMaybeMessage<::validate::FieldRules>(GetArenaNoVirtual());
    keys_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.MapRules.keys)
  return keys_;
}
inline void MapRules::set_allocated_keys(::validate::FieldRules* keys) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete keys_;
  }
  if (keys) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      keys = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, keys, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keys_ = keys;
  // @@protoc_insertion_point(field_set_allocated:validate.MapRules.keys)
}

// optional .validate.FieldRules values = 5;
inline bool MapRules::has_values() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapRules::clear_values() {
  if (values_ != nullptr) values_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::validate::FieldRules& MapRules::values() const {
  const ::validate::FieldRules* p = values_;
  // @@protoc_insertion_point(field_get:validate.MapRules.values)
  return p != nullptr ? *p : *reinterpret_cast<const ::validate::FieldRules*>(
      &::validate::_FieldRules_default_instance_);
}
inline ::validate::FieldRules* MapRules::release_values() {
  // @@protoc_insertion_point(field_release:validate.MapRules.values)
  _has_bits_[0] &= ~0x00000002u;
  ::validate::FieldRules* temp = values_;
  values_ = nullptr;
  return temp;
}
inline ::validate::FieldRules* MapRules::mutable_values() {
  _has_bits_[0] |= 0x00000002u;
  if (values_ == nullptr) {
    auto* p = CreateMaybeMessage<::validate::FieldRules>(GetArenaNoVirtual());
    values_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.MapRules.values)
  return values_;
}
inline void MapRules::set_allocated_values(::validate::FieldRules* values) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete values_;
  }
  if (values) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      values = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, values, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  values_ = values;
  // @@protoc_insertion_point(field_set_allocated:validate.MapRules.values)
}

// -------------------------------------------------------------------

// AnyRules

// optional bool required = 1;
inline bool AnyRules::has_required() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnyRules::clear_required() {
  required_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AnyRules::required() const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.required)
  return required_;
}
inline void AnyRules::set_required(bool value) {
  _has_bits_[0] |= 0x00000001u;
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.AnyRules.required)
}

// repeated string in = 2;
inline int AnyRules::in_size() const {
  return in_.size();
}
inline void AnyRules::clear_in() {
  in_.Clear();
}
inline const ::std::string& AnyRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.in)
  return in_.Get(index);
}
inline ::std::string* AnyRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.AnyRules.in)
  return in_.Mutable(index);
}
inline void AnyRules::set_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.in)
  in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AnyRules::set_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.in)
  in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AnyRules::set_in(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, const char* value, size_t size) {
  in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.AnyRules.in)
}
inline ::std::string* AnyRules::add_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.AnyRules.in)
  return in_.Add();
}
inline void AnyRules::add_in(const ::std::string& value) {
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.AnyRules.in)
}
#if LANG_CXX11
inline void AnyRules::add_in(::std::string&& value) {
  in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.AnyRules.in)
}
#endif
inline void AnyRules::add_in(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.AnyRules.in)
}
inline void AnyRules::add_in(const char* value, size_t size) {
  in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.AnyRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
AnyRules::in() const {
  // @@protoc_insertion_point(field_list:validate.AnyRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
AnyRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.AnyRules.in)
  return &in_;
}

// repeated string not_in = 3;
inline int AnyRules::not_in_size() const {
  return not_in_.size();
}
inline void AnyRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::std::string& AnyRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.not_in)
  return not_in_.Get(index);
}
inline ::std::string* AnyRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.AnyRules.not_in)
  return not_in_.Mutable(index);
}
inline void AnyRules::set_not_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.not_in)
  not_in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AnyRules::set_not_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.not_in)
  not_in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AnyRules::set_not_in(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, const char* value, size_t size) {
  not_in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.AnyRules.not_in)
}
inline ::std::string* AnyRules::add_not_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.AnyRules.not_in)
  return not_in_.Add();
}
inline void AnyRules::add_not_in(const ::std::string& value) {
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.AnyRules.not_in)
}
#if LANG_CXX11
inline void AnyRules::add_not_in(::std::string&& value) {
  not_in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.AnyRules.not_in)
}
#endif
inline void AnyRules::add_not_in(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const char* value, size_t size) {
  not_in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.AnyRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
AnyRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.AnyRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
AnyRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.AnyRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// DurationRules

// optional bool required = 1;
inline bool DurationRules::has_required() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DurationRules::clear_required() {
  required_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool DurationRules::required() const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.required)
  return required_;
}
inline void DurationRules::set_required(bool value) {
  _has_bits_[0] |= 0x00000020u;
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.DurationRules.required)
}

// optional .google.protobuf.Duration const = 2;
inline bool DurationRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::google::protobuf::Duration& DurationRules::const_() const {
  const ::google::protobuf::Duration* p = const__;
  // @@protoc_insertion_point(field_get:validate.DurationRules.const)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.const)
  _has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = const__;
  const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::mutable_const_() {
  _has_bits_[0] |= 0x00000001u;
  if (const__ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    const__ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.const)
  return const__;
}
inline void DurationRules::set_allocated_const_(::google::protobuf::Duration* const_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(const__);
  }
  if (const_) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(const_)->GetArena();
    if (message_arena != submessage_arena) {
      const_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, const_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  const__ = const_;
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.const)
}

// optional .google.protobuf.Duration lt = 3;
inline bool DurationRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::google::protobuf::Duration& DurationRules::lt() const {
  const ::google::protobuf::Duration* p = lt_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.lt)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::release_lt() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.lt)
  _has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = lt_;
  lt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::mutable_lt() {
  _has_bits_[0] |= 0x00000002u;
  if (lt_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    lt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.lt)
  return lt_;
}
inline void DurationRules::set_allocated_lt(::google::protobuf::Duration* lt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lt_);
  }
  if (lt) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lt)->GetArena();
    if (message_arena != submessage_arena) {
      lt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lt_ = lt;
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.lt)
}

// optional .google.protobuf.Duration lte = 4;
inline bool DurationRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::google::protobuf::Duration& DurationRules::lte() const {
  const ::google::protobuf::Duration* p = lte_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.lte)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::release_lte() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.lte)
  _has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = lte_;
  lte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::mutable_lte() {
  _has_bits_[0] |= 0x00000004u;
  if (lte_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    lte_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.lte)
  return lte_;
}
inline void DurationRules::set_allocated_lte(::google::protobuf::Duration* lte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lte_);
  }
  if (lte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lte)->GetArena();
    if (message_arena != submessage_arena) {
      lte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lte, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  lte_ = lte;
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.lte)
}

// optional .google.protobuf.Duration gt = 5;
inline bool DurationRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::google::protobuf::Duration& DurationRules::gt() const {
  const ::google::protobuf::Duration* p = gt_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.gt)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::release_gt() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.gt)
  _has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = gt_;
  gt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::mutable_gt() {
  _has_bits_[0] |= 0x00000008u;
  if (gt_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    gt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.gt)
  return gt_;
}
inline void DurationRules::set_allocated_gt(::google::protobuf::Duration* gt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gt_);
  }
  if (gt) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(gt)->GetArena();
    if (message_arena != submessage_arena) {
      gt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  gt_ = gt;
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.gt)
}

// optional .google.protobuf.Duration gte = 6;
inline bool DurationRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline const ::google::protobuf::Duration& DurationRules::gte() const {
  const ::google::protobuf::Duration* p = gte_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.gte)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::release_gte() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.gte)
  _has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Duration* temp = gte_;
  gte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::mutable_gte() {
  _has_bits_[0] |= 0x00000010u;
  if (gte_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    gte_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.gte)
  return gte_;
}
inline void DurationRules::set_allocated_gte(::google::protobuf::Duration* gte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gte_);
  }
  if (gte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(gte)->GetArena();
    if (message_arena != submessage_arena) {
      gte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gte, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  gte_ = gte;
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.gte)
}

// repeated .google.protobuf.Duration in = 7;
inline int DurationRules::in_size() const {
  return in_.size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.in)
  return in_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
DurationRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DurationRules.in)
  return &in_;
}
inline const ::google::protobuf::Duration& DurationRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.in)
  return in_.Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_in() {
  // @@protoc_insertion_point(field_add:validate.DurationRules.in)
  return in_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
DurationRules::in() const {
  // @@protoc_insertion_point(field_list:validate.DurationRules.in)
  return in_;
}

// repeated .google.protobuf.Duration not_in = 8;
inline int DurationRules::not_in_size() const {
  return not_in_.size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.not_in)
  return not_in_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
DurationRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DurationRules.not_in)
  return &not_in_;
}
inline const ::google::protobuf::Duration& DurationRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.not_in)
  return not_in_.Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_not_in() {
  // @@protoc_insertion_point(field_add:validate.DurationRules.not_in)
  return not_in_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
DurationRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.DurationRules.not_in)
  return not_in_;
}

// -------------------------------------------------------------------

// TimestampRules

// optional bool required = 1;
inline bool TimestampRules::has_required() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TimestampRules::clear_required() {
  required_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool TimestampRules::required() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.required)
  return required_;
}
inline void TimestampRules::set_required(bool value) {
  _has_bits_[0] |= 0x00000040u;
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.required)
}

// optional .google.protobuf.Timestamp const = 2;
inline bool TimestampRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::google::protobuf::Timestamp& TimestampRules::const_() const {
  const ::google::protobuf::Timestamp* p = const__;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.const)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.const)
  _has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = const__;
  const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_const_() {
  _has_bits_[0] |= 0x00000001u;
  if (const__ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    const__ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.const)
  return const__;
}
inline void TimestampRules::set_allocated_const_(::google::protobuf::Timestamp* const_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(const__);
  }
  if (const_) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(const_)->GetArena();
    if (message_arena != submessage_arena) {
      const_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, const_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  const__ = const_;
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.const)
}

// optional .google.protobuf.Timestamp lt = 3;
inline bool TimestampRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::google::protobuf::Timestamp& TimestampRules::lt() const {
  const ::google::protobuf::Timestamp* p = lt_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lt)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lt() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.lt)
  _has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = lt_;
  lt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lt() {
  _has_bits_[0] |= 0x00000002u;
  if (lt_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    lt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.lt)
  return lt_;
}
inline void TimestampRules::set_allocated_lt(::google::protobuf::Timestamp* lt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lt_);
  }
  if (lt) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lt)->GetArena();
    if (message_arena != submessage_arena) {
      lt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lt_ = lt;
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.lt)
}

// optional .google.protobuf.Timestamp lte = 4;
inline bool TimestampRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::google::protobuf::Timestamp& TimestampRules::lte() const {
  const ::google::protobuf::Timestamp* p = lte_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lte)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lte() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.lte)
  _has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = lte_;
  lte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lte() {
  _has_bits_[0] |= 0x00000004u;
  if (lte_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    lte_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.lte)
  return lte_;
}
inline void TimestampRules::set_allocated_lte(::google::protobuf::Timestamp* lte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lte_);
  }
  if (lte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lte)->GetArena();
    if (message_arena != submessage_arena) {
      lte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lte, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  lte_ = lte;
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.lte)
}

// optional .google.protobuf.Timestamp gt = 5;
inline bool TimestampRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::google::protobuf::Timestamp& TimestampRules::gt() const {
  const ::google::protobuf::Timestamp* p = gt_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gt)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gt() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.gt)
  _has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* temp = gt_;
  gt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gt() {
  _has_bits_[0] |= 0x00000008u;
  if (gt_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    gt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.gt)
  return gt_;
}
inline void TimestampRules::set_allocated_gt(::google::protobuf::Timestamp* gt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gt_);
  }
  if (gt) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(gt)->GetArena();
    if (message_arena != submessage_arena) {
      gt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  gt_ = gt;
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.gt)
}

// optional .google.protobuf.Timestamp gte = 6;
inline bool TimestampRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline const ::google::protobuf::Timestamp& TimestampRules::gte() const {
  const ::google::protobuf::Timestamp* p = gte_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gte)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gte() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.gte)
  _has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* temp = gte_;
  gte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gte() {
  _has_bits_[0] |= 0x00000010u;
  if (gte_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    gte_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.gte)
  return gte_;
}
inline void TimestampRules::set_allocated_gte(::google::protobuf::Timestamp* gte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gte_);
  }
  if (gte) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(gte)->GetArena();
    if (message_arena != submessage_arena) {
      gte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gte, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  gte_ = gte;
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.gte)
}

// optional bool lt_now = 7;
inline bool TimestampRules::has_lt_now() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TimestampRules::clear_lt_now() {
  lt_now_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool TimestampRules::lt_now() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lt_now)
  return lt_now_;
}
inline void TimestampRules::set_lt_now(bool value) {
  _has_bits_[0] |= 0x00000080u;
  lt_now_ = value;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.lt_now)
}

// optional bool gt_now = 8;
inline bool TimestampRules::has_gt_now() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TimestampRules::clear_gt_now() {
  gt_now_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool TimestampRules::gt_now() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gt_now)
  return gt_now_;
}
inline void TimestampRules::set_gt_now(bool value) {
  _has_bits_[0] |= 0x00000100u;
  gt_now_ = value;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.gt_now)
}

// optional .google.protobuf.Duration within = 9;
inline bool TimestampRules::has_within() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline const ::google::protobuf::Duration& TimestampRules::within() const {
  const ::google::protobuf::Duration* p = within_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.within)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* TimestampRules::release_within() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.within)
  _has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* temp = within_;
  within_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* TimestampRules::mutable_within() {
  _has_bits_[0] |= 0x00000020u;
  if (within_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    within_ = p;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.within)
  return within_;
}
inline void TimestampRules::set_allocated_within(::google::protobuf::Duration* within) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(within_);
  }
  if (within) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(within)->GetArena();
    if (message_arena != submessage_arena) {
      within = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, within, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  within_ = within;
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.within)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace validate

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_validate_2fvalidate_2eproto
