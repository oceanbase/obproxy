// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validate/validate.proto

#include "validate/validate.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_google_2fprotobuf_2fduration_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Duration_google_2fprotobuf_2fduration_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_google_2fprotobuf_2ftimestamp_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Timestamp_google_2fprotobuf_2ftimestamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AnyRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BoolRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BytesRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_DoubleRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_EnumRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Fixed32Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Fixed64Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_FloatRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Int32Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Int64Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_MessageRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SFixed32Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SFixed64Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SInt32Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SInt64Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_StringRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_UInt32Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_UInt64Rules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_DurationRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<20> scc_info_FieldRules_validate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_TimestampRules_validate_2fvalidate_2eproto;
namespace validate {
class FieldRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FieldRules> _instance;
  const ::validate::FloatRules* float__;
  const ::validate::DoubleRules* double__;
  const ::validate::Int32Rules* int32_;
  const ::validate::Int64Rules* int64_;
  const ::validate::UInt32Rules* uint32_;
  const ::validate::UInt64Rules* uint64_;
  const ::validate::SInt32Rules* sint32_;
  const ::validate::SInt64Rules* sint64_;
  const ::validate::Fixed32Rules* fixed32_;
  const ::validate::Fixed64Rules* fixed64_;
  const ::validate::SFixed32Rules* sfixed32_;
  const ::validate::SFixed64Rules* sfixed64_;
  const ::validate::BoolRules* bool__;
  const ::validate::StringRules* string_;
  const ::validate::BytesRules* bytes_;
  const ::validate::EnumRules* enum__;
  const ::validate::MessageRules* message_;
  const ::validate::RepeatedRules* repeated_;
  const ::validate::MapRules* map_;
  const ::validate::AnyRules* any_;
  const ::validate::DurationRules* duration_;
  const ::validate::TimestampRules* timestamp_;
} _FieldRules_default_instance_;
class FloatRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FloatRules> _instance;
} _FloatRules_default_instance_;
class DoubleRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DoubleRules> _instance;
} _DoubleRules_default_instance_;
class Int32RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Int32Rules> _instance;
} _Int32Rules_default_instance_;
class Int64RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Int64Rules> _instance;
} _Int64Rules_default_instance_;
class UInt32RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UInt32Rules> _instance;
} _UInt32Rules_default_instance_;
class UInt64RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UInt64Rules> _instance;
} _UInt64Rules_default_instance_;
class SInt32RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SInt32Rules> _instance;
} _SInt32Rules_default_instance_;
class SInt64RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SInt64Rules> _instance;
} _SInt64Rules_default_instance_;
class Fixed32RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Fixed32Rules> _instance;
} _Fixed32Rules_default_instance_;
class Fixed64RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Fixed64Rules> _instance;
} _Fixed64Rules_default_instance_;
class SFixed32RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SFixed32Rules> _instance;
} _SFixed32Rules_default_instance_;
class SFixed64RulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SFixed64Rules> _instance;
} _SFixed64Rules_default_instance_;
class BoolRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BoolRules> _instance;
} _BoolRules_default_instance_;
class StringRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<StringRules> _instance;
  bool email_;
  bool hostname_;
  bool ip_;
  bool ipv4_;
  bool ipv6_;
  bool uri_;
  bool uri_ref_;
} _StringRules_default_instance_;
class BytesRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BytesRules> _instance;
  bool ip_;
  bool ipv4_;
  bool ipv6_;
} _BytesRules_default_instance_;
class EnumRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EnumRules> _instance;
} _EnumRules_default_instance_;
class MessageRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MessageRules> _instance;
} _MessageRules_default_instance_;
class RepeatedRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RepeatedRules> _instance;
} _RepeatedRules_default_instance_;
class MapRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MapRules> _instance;
} _MapRules_default_instance_;
class AnyRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AnyRules> _instance;
} _AnyRules_default_instance_;
class DurationRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DurationRules> _instance;
} _DurationRules_default_instance_;
class TimestampRulesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TimestampRules> _instance;
} _TimestampRules_default_instance_;
}  // namespace validate
static void InitDefaultsFieldRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_FieldRules_default_instance_;
    new (ptr) ::validate::FieldRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::validate::_RepeatedRules_default_instance_;
    new (ptr) ::validate::RepeatedRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::validate::_MapRules_default_instance_;
    new (ptr) ::validate::MapRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::FieldRules::InitAsDefaultInstance();
  ::validate::RepeatedRules::InitAsDefaultInstance();
  ::validate::MapRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<20> scc_info_FieldRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 20, InitDefaultsFieldRules_validate_2fvalidate_2eproto}, {
      &scc_info_FloatRules_validate_2fvalidate_2eproto.base,
      &scc_info_DoubleRules_validate_2fvalidate_2eproto.base,
      &scc_info_Int32Rules_validate_2fvalidate_2eproto.base,
      &scc_info_Int64Rules_validate_2fvalidate_2eproto.base,
      &scc_info_UInt32Rules_validate_2fvalidate_2eproto.base,
      &scc_info_UInt64Rules_validate_2fvalidate_2eproto.base,
      &scc_info_SInt32Rules_validate_2fvalidate_2eproto.base,
      &scc_info_SInt64Rules_validate_2fvalidate_2eproto.base,
      &scc_info_Fixed32Rules_validate_2fvalidate_2eproto.base,
      &scc_info_Fixed64Rules_validate_2fvalidate_2eproto.base,
      &scc_info_SFixed32Rules_validate_2fvalidate_2eproto.base,
      &scc_info_SFixed64Rules_validate_2fvalidate_2eproto.base,
      &scc_info_BoolRules_validate_2fvalidate_2eproto.base,
      &scc_info_StringRules_validate_2fvalidate_2eproto.base,
      &scc_info_BytesRules_validate_2fvalidate_2eproto.base,
      &scc_info_EnumRules_validate_2fvalidate_2eproto.base,
      &scc_info_MessageRules_validate_2fvalidate_2eproto.base,
      &scc_info_AnyRules_validate_2fvalidate_2eproto.base,
      &scc_info_DurationRules_validate_2fvalidate_2eproto.base,
      &scc_info_TimestampRules_validate_2fvalidate_2eproto.base,}};

static void InitDefaultsFloatRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_FloatRules_default_instance_;
    new (ptr) ::validate::FloatRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::FloatRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_FloatRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFloatRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsDoubleRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_DoubleRules_default_instance_;
    new (ptr) ::validate::DoubleRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::DoubleRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_DoubleRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsDoubleRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsInt32Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_Int32Rules_default_instance_;
    new (ptr) ::validate::Int32Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::Int32Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Int32Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsInt32Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsInt64Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_Int64Rules_default_instance_;
    new (ptr) ::validate::Int64Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::Int64Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Int64Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsInt64Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsUInt32Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_UInt32Rules_default_instance_;
    new (ptr) ::validate::UInt32Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::UInt32Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_UInt32Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsUInt32Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsUInt64Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_UInt64Rules_default_instance_;
    new (ptr) ::validate::UInt64Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::UInt64Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_UInt64Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsUInt64Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsSInt32Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_SInt32Rules_default_instance_;
    new (ptr) ::validate::SInt32Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::SInt32Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SInt32Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSInt32Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsSInt64Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_SInt64Rules_default_instance_;
    new (ptr) ::validate::SInt64Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::SInt64Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SInt64Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSInt64Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsFixed32Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_Fixed32Rules_default_instance_;
    new (ptr) ::validate::Fixed32Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::Fixed32Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Fixed32Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFixed32Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsFixed64Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_Fixed64Rules_default_instance_;
    new (ptr) ::validate::Fixed64Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::Fixed64Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Fixed64Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFixed64Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsSFixed32Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_SFixed32Rules_default_instance_;
    new (ptr) ::validate::SFixed32Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::SFixed32Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SFixed32Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSFixed32Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsSFixed64Rules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_SFixed64Rules_default_instance_;
    new (ptr) ::validate::SFixed64Rules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::SFixed64Rules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SFixed64Rules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSFixed64Rules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsBoolRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_BoolRules_default_instance_;
    new (ptr) ::validate::BoolRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::BoolRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BoolRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBoolRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsStringRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_StringRules_default_instance_;
    new (ptr) ::validate::StringRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::StringRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_StringRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsStringRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsBytesRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_BytesRules_default_instance_;
    new (ptr) ::validate::BytesRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::BytesRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BytesRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBytesRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsEnumRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_EnumRules_default_instance_;
    new (ptr) ::validate::EnumRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::EnumRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EnumRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEnumRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsMessageRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_MessageRules_default_instance_;
    new (ptr) ::validate::MessageRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::MessageRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_MessageRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsMessageRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsAnyRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_AnyRules_default_instance_;
    new (ptr) ::validate::AnyRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::AnyRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AnyRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAnyRules_validate_2fvalidate_2eproto}, {}};

static void InitDefaultsDurationRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_DurationRules_default_instance_;
    new (ptr) ::validate::DurationRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::DurationRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_DurationRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsDurationRules_validate_2fvalidate_2eproto}, {
      &scc_info_Duration_google_2fprotobuf_2fduration_2eproto.base,}};

static void InitDefaultsTimestampRules_validate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::validate::_TimestampRules_default_instance_;
    new (ptr) ::validate::TimestampRules();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::validate::TimestampRules::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_TimestampRules_validate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsTimestampRules_validate_2fvalidate_2eproto}, {
      &scc_info_Timestamp_google_2fprotobuf_2ftimestamp_2eproto.base,
      &scc_info_Duration_google_2fprotobuf_2fduration_2eproto.base,}};

void InitDefaults_validate_2fvalidate_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_FloatRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_DoubleRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Int32Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Int64Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UInt32Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UInt64Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SInt32Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SInt64Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Fixed32Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Fixed64Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SFixed32Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SFixed64Rules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BoolRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_StringRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BytesRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EnumRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_MessageRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AnyRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_DurationRules_validate_2fvalidate_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TimestampRules_validate_2fvalidate_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_validate_2fvalidate_2eproto[23];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_validate_2fvalidate_2eproto = nullptr;
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_validate_2fvalidate_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_validate_2fvalidate_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::validate::FieldRulesDefaultTypeInternal, float__),
  offsetof(::validate::FieldRulesDefaultTypeInternal, double__),
  offsetof(::validate::FieldRulesDefaultTypeInternal, int32_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, int64_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, uint32_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, uint64_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, sint32_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, sint64_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, fixed32_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, fixed64_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, sfixed32_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, sfixed64_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, bool__),
  offsetof(::validate::FieldRulesDefaultTypeInternal, string_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, bytes_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, enum__),
  offsetof(::validate::FieldRulesDefaultTypeInternal, message_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, repeated_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, map_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, any_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, duration_),
  offsetof(::validate::FieldRulesDefaultTypeInternal, timestamp_),
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, type_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, const__),
  0,
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, min_len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, max_len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, len_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, min_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, max_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, pattern_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, prefix_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, suffix_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, contains_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, not_in_),
  offsetof(::validate::StringRulesDefaultTypeInternal, email_),
  offsetof(::validate::StringRulesDefaultTypeInternal, hostname_),
  offsetof(::validate::StringRulesDefaultTypeInternal, ip_),
  offsetof(::validate::StringRulesDefaultTypeInternal, ipv4_),
  offsetof(::validate::StringRulesDefaultTypeInternal, ipv6_),
  offsetof(::validate::StringRulesDefaultTypeInternal, uri_),
  offsetof(::validate::StringRulesDefaultTypeInternal, uri_ref_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, well_known_),
  0,
  9,
  5,
  6,
  10,
  7,
  8,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, min_len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, max_len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, pattern_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, prefix_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, suffix_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, contains_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, not_in_),
  offsetof(::validate::BytesRulesDefaultTypeInternal, ip_),
  offsetof(::validate::BytesRulesDefaultTypeInternal, ipv4_),
  offsetof(::validate::BytesRulesDefaultTypeInternal, ipv6_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, well_known_),
  0,
  7,
  5,
  6,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, defined_only_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, not_in_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, skip_),
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, required_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, min_items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, max_items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, unique_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, items_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, min_pairs_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, max_pairs_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, no_sparse_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, keys_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, values_),
  2,
  3,
  4,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, required_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, not_in_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, required_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, not_in_),
  5,
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, required_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, lt_now_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, gt_now_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, within_),
  6,
  0,
  1,
  2,
  3,
  4,
  7,
  8,
  5,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 28, sizeof(::validate::FieldRules)},
  { 50, 62, sizeof(::validate::FloatRules)},
  { 69, 81, sizeof(::validate::DoubleRules)},
  { 88, 100, sizeof(::validate::Int32Rules)},
  { 107, 119, sizeof(::validate::Int64Rules)},
  { 126, 138, sizeof(::validate::UInt32Rules)},
  { 145, 157, sizeof(::validate::UInt64Rules)},
  { 164, 176, sizeof(::validate::SInt32Rules)},
  { 183, 195, sizeof(::validate::SInt64Rules)},
  { 202, 214, sizeof(::validate::Fixed32Rules)},
  { 221, 233, sizeof(::validate::Fixed64Rules)},
  { 240, 252, sizeof(::validate::SFixed32Rules)},
  { 259, 271, sizeof(::validate::SFixed64Rules)},
  { 278, 284, sizeof(::validate::BoolRules)},
  { 285, 311, sizeof(::validate::StringRules)},
  { 331, 350, sizeof(::validate::BytesRules)},
  { 363, 372, sizeof(::validate::EnumRules)},
  { 376, 383, sizeof(::validate::MessageRules)},
  { 385, 394, sizeof(::validate::RepeatedRules)},
  { 398, 408, sizeof(::validate::MapRules)},
  { 413, 421, sizeof(::validate::AnyRules)},
  { 424, 437, sizeof(::validate::DurationRules)},
  { 445, 459, sizeof(::validate::TimestampRules)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_FieldRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_FloatRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_DoubleRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_Int32Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_Int64Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_UInt32Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_UInt64Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_SInt32Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_SInt64Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_Fixed32Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_Fixed64Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_SFixed32Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_SFixed64Rules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_BoolRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_StringRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_BytesRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_EnumRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_MessageRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_RepeatedRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_MapRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_AnyRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_DurationRules_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::validate::_TimestampRules_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_validate_2fvalidate_2eproto = {
  {}, AddDescriptors_validate_2fvalidate_2eproto, "validate/validate.proto", schemas,
  file_default_instances, TableStruct_validate_2fvalidate_2eproto::offsets,
  file_level_metadata_validate_2fvalidate_2eproto, 23, file_level_enum_descriptors_validate_2fvalidate_2eproto, file_level_service_descriptors_validate_2fvalidate_2eproto,
};

const char descriptor_table_protodef_validate_2fvalidate_2eproto[] =
  "\n\027validate/validate.proto\022\010validate\032 goo"
  "gle/protobuf/descriptor.proto\032\036google/pr"
  "otobuf/duration.proto\032\037google/protobuf/t"
  "imestamp.proto\"\232\007\n\nFieldRules\022%\n\005float\030\001"
  " \001(\0132\024.validate.FloatRulesH\000\022\'\n\006double\030\002"
  " \001(\0132\025.validate.DoubleRulesH\000\022%\n\005int32\030\003"
  " \001(\0132\024.validate.Int32RulesH\000\022%\n\005int64\030\004 "
  "\001(\0132\024.validate.Int64RulesH\000\022\'\n\006uint32\030\005 "
  "\001(\0132\025.validate.UInt32RulesH\000\022\'\n\006uint64\030\006"
  " \001(\0132\025.validate.UInt64RulesH\000\022\'\n\006sint32\030"
  "\007 \001(\0132\025.validate.SInt32RulesH\000\022\'\n\006sint64"
  "\030\010 \001(\0132\025.validate.SInt64RulesH\000\022)\n\007fixed"
  "32\030\t \001(\0132\026.validate.Fixed32RulesH\000\022)\n\007fi"
  "xed64\030\n \001(\0132\026.validate.Fixed64RulesH\000\022+\n"
  "\010sfixed32\030\013 \001(\0132\027.validate.SFixed32Rules"
  "H\000\022+\n\010sfixed64\030\014 \001(\0132\027.validate.SFixed64"
  "RulesH\000\022#\n\004bool\030\r \001(\0132\023.validate.BoolRul"
  "esH\000\022\'\n\006string\030\016 \001(\0132\025.validate.StringRu"
  "lesH\000\022%\n\005bytes\030\017 \001(\0132\024.validate.BytesRul"
  "esH\000\022#\n\004enum\030\020 \001(\0132\023.validate.EnumRulesH"
  "\000\022)\n\007message\030\021 \001(\0132\026.validate.MessageRul"
  "esH\000\022+\n\010repeated\030\022 \001(\0132\027.validate.Repeat"
  "edRulesH\000\022!\n\003map\030\023 \001(\0132\022.validate.MapRul"
  "esH\000\022!\n\003any\030\024 \001(\0132\022.validate.AnyRulesH\000\022"
  "+\n\010duration\030\025 \001(\0132\027.validate.DurationRul"
  "esH\000\022-\n\ttimestamp\030\026 \001(\0132\030.validate.Times"
  "tampRulesH\000B\006\n\004type\"i\n\nFloatRules\022\r\n\005con"
  "st\030\001 \001(\002\022\n\n\002lt\030\002 \001(\002\022\013\n\003lte\030\003 \001(\002\022\n\n\002gt\030"
  "\004 \001(\002\022\013\n\003gte\030\005 \001(\002\022\n\n\002in\030\006 \003(\002\022\016\n\006not_in"
  "\030\007 \003(\002\"j\n\013DoubleRules\022\r\n\005const\030\001 \001(\001\022\n\n\002"
  "lt\030\002 \001(\001\022\013\n\003lte\030\003 \001(\001\022\n\n\002gt\030\004 \001(\001\022\013\n\003gte"
  "\030\005 \001(\001\022\n\n\002in\030\006 \003(\001\022\016\n\006not_in\030\007 \003(\001\"i\n\nIn"
  "t32Rules\022\r\n\005const\030\001 \001(\005\022\n\n\002lt\030\002 \001(\005\022\013\n\003l"
  "te\030\003 \001(\005\022\n\n\002gt\030\004 \001(\005\022\013\n\003gte\030\005 \001(\005\022\n\n\002in\030"
  "\006 \003(\005\022\016\n\006not_in\030\007 \003(\005\"i\n\nInt64Rules\022\r\n\005c"
  "onst\030\001 \001(\003\022\n\n\002lt\030\002 \001(\003\022\013\n\003lte\030\003 \001(\003\022\n\n\002g"
  "t\030\004 \001(\003\022\013\n\003gte\030\005 \001(\003\022\n\n\002in\030\006 \003(\003\022\016\n\006not_"
  "in\030\007 \003(\003\"j\n\013UInt32Rules\022\r\n\005const\030\001 \001(\r\022\n"
  "\n\002lt\030\002 \001(\r\022\013\n\003lte\030\003 \001(\r\022\n\n\002gt\030\004 \001(\r\022\013\n\003g"
  "te\030\005 \001(\r\022\n\n\002in\030\006 \003(\r\022\016\n\006not_in\030\007 \003(\r\"j\n\013"
  "UInt64Rules\022\r\n\005const\030\001 \001(\004\022\n\n\002lt\030\002 \001(\004\022\013"
  "\n\003lte\030\003 \001(\004\022\n\n\002gt\030\004 \001(\004\022\013\n\003gte\030\005 \001(\004\022\n\n\002"
  "in\030\006 \003(\004\022\016\n\006not_in\030\007 \003(\004\"j\n\013SInt32Rules\022"
  "\r\n\005const\030\001 \001(\021\022\n\n\002lt\030\002 \001(\021\022\013\n\003lte\030\003 \001(\021\022"
  "\n\n\002gt\030\004 \001(\021\022\013\n\003gte\030\005 \001(\021\022\n\n\002in\030\006 \003(\021\022\016\n\006"
  "not_in\030\007 \003(\021\"j\n\013SInt64Rules\022\r\n\005const\030\001 \001"
  "(\022\022\n\n\002lt\030\002 \001(\022\022\013\n\003lte\030\003 \001(\022\022\n\n\002gt\030\004 \001(\022\022"
  "\013\n\003gte\030\005 \001(\022\022\n\n\002in\030\006 \003(\022\022\016\n\006not_in\030\007 \003(\022"
  "\"k\n\014Fixed32Rules\022\r\n\005const\030\001 \001(\007\022\n\n\002lt\030\002 "
  "\001(\007\022\013\n\003lte\030\003 \001(\007\022\n\n\002gt\030\004 \001(\007\022\013\n\003gte\030\005 \001("
  "\007\022\n\n\002in\030\006 \003(\007\022\016\n\006not_in\030\007 \003(\007\"k\n\014Fixed64"
  "Rules\022\r\n\005const\030\001 \001(\006\022\n\n\002lt\030\002 \001(\006\022\013\n\003lte\030"
  "\003 \001(\006\022\n\n\002gt\030\004 \001(\006\022\013\n\003gte\030\005 \001(\006\022\n\n\002in\030\006 \003"
  "(\006\022\016\n\006not_in\030\007 \003(\006\"l\n\rSFixed32Rules\022\r\n\005c"
  "onst\030\001 \001(\017\022\n\n\002lt\030\002 \001(\017\022\013\n\003lte\030\003 \001(\017\022\n\n\002g"
  "t\030\004 \001(\017\022\013\n\003gte\030\005 \001(\017\022\n\n\002in\030\006 \003(\017\022\016\n\006not_"
  "in\030\007 \003(\017\"l\n\rSFixed64Rules\022\r\n\005const\030\001 \001(\020"
  "\022\n\n\002lt\030\002 \001(\020\022\013\n\003lte\030\003 \001(\020\022\n\n\002gt\030\004 \001(\020\022\013\n"
  "\003gte\030\005 \001(\020\022\n\n\002in\030\006 \003(\020\022\016\n\006not_in\030\007 \003(\020\"\032"
  "\n\tBoolRules\022\r\n\005const\030\001 \001(\010\"\346\002\n\013StringRul"
  "es\022\r\n\005const\030\001 \001(\t\022\013\n\003len\030\023 \001(\004\022\017\n\007min_le"
  "n\030\002 \001(\004\022\017\n\007max_len\030\003 \001(\004\022\021\n\tlen_bytes\030\024 "
  "\001(\004\022\021\n\tmin_bytes\030\004 \001(\004\022\021\n\tmax_bytes\030\005 \001("
  "\004\022\017\n\007pattern\030\006 \001(\t\022\016\n\006prefix\030\007 \001(\t\022\016\n\006su"
  "ffix\030\010 \001(\t\022\020\n\010contains\030\t \001(\t\022\n\n\002in\030\n \003(\t"
  "\022\016\n\006not_in\030\013 \003(\t\022\017\n\005email\030\014 \001(\010H\000\022\022\n\010hos"
  "tname\030\r \001(\010H\000\022\014\n\002ip\030\016 \001(\010H\000\022\016\n\004ipv4\030\017 \001("
  "\010H\000\022\016\n\004ipv6\030\020 \001(\010H\000\022\r\n\003uri\030\021 \001(\010H\000\022\021\n\007ur"
  "i_ref\030\022 \001(\010H\000B\014\n\nwell_known\"\345\001\n\nBytesRul"
  "es\022\r\n\005const\030\001 \001(\014\022\013\n\003len\030\r \001(\004\022\017\n\007min_le"
  "n\030\002 \001(\004\022\017\n\007max_len\030\003 \001(\004\022\017\n\007pattern\030\004 \001("
  "\t\022\016\n\006prefix\030\005 \001(\014\022\016\n\006suffix\030\006 \001(\014\022\020\n\010con"
  "tains\030\007 \001(\014\022\n\n\002in\030\010 \003(\014\022\016\n\006not_in\030\t \003(\014\022"
  "\014\n\002ip\030\n \001(\010H\000\022\016\n\004ipv4\030\013 \001(\010H\000\022\016\n\004ipv6\030\014 "
  "\001(\010H\000B\014\n\nwell_known\"L\n\tEnumRules\022\r\n\005cons"
  "t\030\001 \001(\005\022\024\n\014defined_only\030\002 \001(\010\022\n\n\002in\030\003 \003("
  "\005\022\016\n\006not_in\030\004 \003(\005\".\n\014MessageRules\022\014\n\004ski"
  "p\030\001 \001(\010\022\020\n\010required\030\002 \001(\010\"j\n\rRepeatedRul"
  "es\022\021\n\tmin_items\030\001 \001(\004\022\021\n\tmax_items\030\002 \001(\004"
  "\022\016\n\006unique\030\003 \001(\010\022#\n\005items\030\004 \001(\0132\024.valida"
  "te.FieldRules\"\215\001\n\010MapRules\022\021\n\tmin_pairs\030"
  "\001 \001(\004\022\021\n\tmax_pairs\030\002 \001(\004\022\021\n\tno_sparse\030\003 "
  "\001(\010\022\"\n\004keys\030\004 \001(\0132\024.validate.FieldRules\022"
  "$\n\006values\030\005 \001(\0132\024.validate.FieldRules\"8\n"
  "\010AnyRules\022\020\n\010required\030\001 \001(\010\022\n\n\002in\030\002 \003(\t\022"
  "\016\n\006not_in\030\003 \003(\t\"\273\002\n\rDurationRules\022\020\n\010req"
  "uired\030\001 \001(\010\022(\n\005const\030\002 \001(\0132\031.google.prot"
  "obuf.Duration\022%\n\002lt\030\003 \001(\0132\031.google.proto"
  "buf.Duration\022&\n\003lte\030\004 \001(\0132\031.google.proto"
  "buf.Duration\022%\n\002gt\030\005 \001(\0132\031.google.protob"
  "uf.Duration\022&\n\003gte\030\006 \001(\0132\031.google.protob"
  "uf.Duration\022%\n\002in\030\007 \003(\0132\031.google.protobu"
  "f.Duration\022)\n\006not_in\030\010 \003(\0132\031.google.prot"
  "obuf.Duration\"\272\002\n\016TimestampRules\022\020\n\010requ"
  "ired\030\001 \001(\010\022)\n\005const\030\002 \001(\0132\032.google.proto"
  "buf.Timestamp\022&\n\002lt\030\003 \001(\0132\032.google.proto"
  "buf.Timestamp\022\'\n\003lte\030\004 \001(\0132\032.google.prot"
  "obuf.Timestamp\022&\n\002gt\030\005 \001(\0132\032.google.prot"
  "obuf.Timestamp\022\'\n\003gte\030\006 \001(\0132\032.google.pro"
  "tobuf.Timestamp\022\016\n\006lt_now\030\007 \001(\010\022\016\n\006gt_no"
  "w\030\010 \001(\010\022)\n\006within\030\t \001(\0132\031.google.protobu"
  "f.Duration:3\n\010disabled\022\037.google.protobuf"
  ".MessageOptions\030\227\2158 \001(\010:1\n\010required\022\035.go"
  "ogle.protobuf.OneofOptions\030\227\2158 \001(\010:D\n\005ru"
  "les\022\035.google.protobuf.FieldOptions\030\227\2158 \001"
  "(\0132\024.validate.FieldRulesB.Z,github.com/l"
  "yft/protoc-gen-validate/validate"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_validate_2fvalidate_2eproto = {
  false, InitDefaults_validate_2fvalidate_2eproto, 
  descriptor_table_protodef_validate_2fvalidate_2eproto,
  "validate/validate.proto", &assign_descriptors_table_validate_2fvalidate_2eproto, 4272,
};

void AddDescriptors_validate_2fvalidate_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[3] =
  {
    ::AddDescriptors_google_2fprotobuf_2fdescriptor_2eproto,
    ::AddDescriptors_google_2fprotobuf_2fduration_2eproto,
    ::AddDescriptors_google_2fprotobuf_2ftimestamp_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_validate_2fvalidate_2eproto, deps, 3);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_validate_2fvalidate_2eproto = []() { AddDescriptors_validate_2fvalidate_2eproto(); return true; }();
namespace validate {

// ===================================================================

void FieldRules::InitAsDefaultInstance() {
  ::validate::_FieldRules_default_instance_.float__ = const_cast< ::validate::FloatRules*>(
      ::validate::FloatRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.double__ = const_cast< ::validate::DoubleRules*>(
      ::validate::DoubleRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.int32_ = const_cast< ::validate::Int32Rules*>(
      ::validate::Int32Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.int64_ = const_cast< ::validate::Int64Rules*>(
      ::validate::Int64Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.uint32_ = const_cast< ::validate::UInt32Rules*>(
      ::validate::UInt32Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.uint64_ = const_cast< ::validate::UInt64Rules*>(
      ::validate::UInt64Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.sint32_ = const_cast< ::validate::SInt32Rules*>(
      ::validate::SInt32Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.sint64_ = const_cast< ::validate::SInt64Rules*>(
      ::validate::SInt64Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.fixed32_ = const_cast< ::validate::Fixed32Rules*>(
      ::validate::Fixed32Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.fixed64_ = const_cast< ::validate::Fixed64Rules*>(
      ::validate::Fixed64Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.sfixed32_ = const_cast< ::validate::SFixed32Rules*>(
      ::validate::SFixed32Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.sfixed64_ = const_cast< ::validate::SFixed64Rules*>(
      ::validate::SFixed64Rules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.bool__ = const_cast< ::validate::BoolRules*>(
      ::validate::BoolRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.string_ = const_cast< ::validate::StringRules*>(
      ::validate::StringRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.bytes_ = const_cast< ::validate::BytesRules*>(
      ::validate::BytesRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.enum__ = const_cast< ::validate::EnumRules*>(
      ::validate::EnumRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.message_ = const_cast< ::validate::MessageRules*>(
      ::validate::MessageRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.repeated_ = const_cast< ::validate::RepeatedRules*>(
      ::validate::RepeatedRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.map_ = const_cast< ::validate::MapRules*>(
      ::validate::MapRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.any_ = const_cast< ::validate::AnyRules*>(
      ::validate::AnyRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.duration_ = const_cast< ::validate::DurationRules*>(
      ::validate::DurationRules::internal_default_instance());
  ::validate::_FieldRules_default_instance_.timestamp_ = const_cast< ::validate::TimestampRules*>(
      ::validate::TimestampRules::internal_default_instance());
}
class FieldRules::HasBitSetters {
 public:
  static const ::validate::FloatRules& float_(const FieldRules* msg);
  static const ::validate::DoubleRules& double_(const FieldRules* msg);
  static const ::validate::Int32Rules& int32(const FieldRules* msg);
  static const ::validate::Int64Rules& int64(const FieldRules* msg);
  static const ::validate::UInt32Rules& uint32(const FieldRules* msg);
  static const ::validate::UInt64Rules& uint64(const FieldRules* msg);
  static const ::validate::SInt32Rules& sint32(const FieldRules* msg);
  static const ::validate::SInt64Rules& sint64(const FieldRules* msg);
  static const ::validate::Fixed32Rules& fixed32(const FieldRules* msg);
  static const ::validate::Fixed64Rules& fixed64(const FieldRules* msg);
  static const ::validate::SFixed32Rules& sfixed32(const FieldRules* msg);
  static const ::validate::SFixed64Rules& sfixed64(const FieldRules* msg);
  static const ::validate::BoolRules& bool_(const FieldRules* msg);
  static const ::validate::StringRules& string(const FieldRules* msg);
  static const ::validate::BytesRules& bytes(const FieldRules* msg);
  static const ::validate::EnumRules& enum_(const FieldRules* msg);
  static const ::validate::MessageRules& message(const FieldRules* msg);
  static const ::validate::RepeatedRules& repeated(const FieldRules* msg);
  static const ::validate::MapRules& map(const FieldRules* msg);
  static const ::validate::AnyRules& any(const FieldRules* msg);
  static const ::validate::DurationRules& duration(const FieldRules* msg);
  static const ::validate::TimestampRules& timestamp(const FieldRules* msg);
};

const ::validate::FloatRules&
FieldRules::HasBitSetters::float_(const FieldRules* msg) {
  return *msg->type_.float__;
}
const ::validate::DoubleRules&
FieldRules::HasBitSetters::double_(const FieldRules* msg) {
  return *msg->type_.double__;
}
const ::validate::Int32Rules&
FieldRules::HasBitSetters::int32(const FieldRules* msg) {
  return *msg->type_.int32_;
}
const ::validate::Int64Rules&
FieldRules::HasBitSetters::int64(const FieldRules* msg) {
  return *msg->type_.int64_;
}
const ::validate::UInt32Rules&
FieldRules::HasBitSetters::uint32(const FieldRules* msg) {
  return *msg->type_.uint32_;
}
const ::validate::UInt64Rules&
FieldRules::HasBitSetters::uint64(const FieldRules* msg) {
  return *msg->type_.uint64_;
}
const ::validate::SInt32Rules&
FieldRules::HasBitSetters::sint32(const FieldRules* msg) {
  return *msg->type_.sint32_;
}
const ::validate::SInt64Rules&
FieldRules::HasBitSetters::sint64(const FieldRules* msg) {
  return *msg->type_.sint64_;
}
const ::validate::Fixed32Rules&
FieldRules::HasBitSetters::fixed32(const FieldRules* msg) {
  return *msg->type_.fixed32_;
}
const ::validate::Fixed64Rules&
FieldRules::HasBitSetters::fixed64(const FieldRules* msg) {
  return *msg->type_.fixed64_;
}
const ::validate::SFixed32Rules&
FieldRules::HasBitSetters::sfixed32(const FieldRules* msg) {
  return *msg->type_.sfixed32_;
}
const ::validate::SFixed64Rules&
FieldRules::HasBitSetters::sfixed64(const FieldRules* msg) {
  return *msg->type_.sfixed64_;
}
const ::validate::BoolRules&
FieldRules::HasBitSetters::bool_(const FieldRules* msg) {
  return *msg->type_.bool__;
}
const ::validate::StringRules&
FieldRules::HasBitSetters::string(const FieldRules* msg) {
  return *msg->type_.string_;
}
const ::validate::BytesRules&
FieldRules::HasBitSetters::bytes(const FieldRules* msg) {
  return *msg->type_.bytes_;
}
const ::validate::EnumRules&
FieldRules::HasBitSetters::enum_(const FieldRules* msg) {
  return *msg->type_.enum__;
}
const ::validate::MessageRules&
FieldRules::HasBitSetters::message(const FieldRules* msg) {
  return *msg->type_.message_;
}
const ::validate::RepeatedRules&
FieldRules::HasBitSetters::repeated(const FieldRules* msg) {
  return *msg->type_.repeated_;
}
const ::validate::MapRules&
FieldRules::HasBitSetters::map(const FieldRules* msg) {
  return *msg->type_.map_;
}
const ::validate::AnyRules&
FieldRules::HasBitSetters::any(const FieldRules* msg) {
  return *msg->type_.any_;
}
const ::validate::DurationRules&
FieldRules::HasBitSetters::duration(const FieldRules* msg) {
  return *msg->type_.duration_;
}
const ::validate::TimestampRules&
FieldRules::HasBitSetters::timestamp(const FieldRules* msg) {
  return *msg->type_.timestamp_;
}
void FieldRules::set_allocated_float_(::validate::FloatRules* float_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (float_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      float_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, float_, submessage_arena);
    }
    set_has_float_();
    type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.float)
}
void FieldRules::set_allocated_double_(::validate::DoubleRules* double_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (double_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      double_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, double_, submessage_arena);
    }
    set_has_double_();
    type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.double)
}
void FieldRules::set_allocated_int32(::validate::Int32Rules* int32) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (int32) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      int32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, int32, submessage_arena);
    }
    set_has_int32();
    type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int32)
}
void FieldRules::set_allocated_int64(::validate::Int64Rules* int64) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (int64) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      int64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, int64, submessage_arena);
    }
    set_has_int64();
    type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int64)
}
void FieldRules::set_allocated_uint32(::validate::UInt32Rules* uint32) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (uint32) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      uint32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint32)
}
void FieldRules::set_allocated_uint64(::validate::UInt64Rules* uint64) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (uint64) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      uint64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint64)
}
void FieldRules::set_allocated_sint32(::validate::SInt32Rules* sint32) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (sint32) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sint32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint32)
}
void FieldRules::set_allocated_sint64(::validate::SInt64Rules* sint64) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (sint64) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sint64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint64)
}
void FieldRules::set_allocated_fixed32(::validate::Fixed32Rules* fixed32) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (fixed32) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fixed32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed32)
}
void FieldRules::set_allocated_fixed64(::validate::Fixed64Rules* fixed64) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (fixed64) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fixed64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed64)
}
void FieldRules::set_allocated_sfixed32(::validate::SFixed32Rules* sfixed32) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (sfixed32) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sfixed32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed32)
}
void FieldRules::set_allocated_sfixed64(::validate::SFixed64Rules* sfixed64) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (sfixed64) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sfixed64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed64)
}
void FieldRules::set_allocated_bool_(::validate::BoolRules* bool_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (bool_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bool_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bool)
}
void FieldRules::set_allocated_string(::validate::StringRules* string) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (string) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      string = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, string, submessage_arena);
    }
    set_has_string();
    type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.string)
}
void FieldRules::set_allocated_bytes(::validate::BytesRules* bytes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (bytes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bytes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bytes)
}
void FieldRules::set_allocated_enum_(::validate::EnumRules* enum_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (enum_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      enum_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.enum)
}
void FieldRules::set_allocated_message(::validate::MessageRules* message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (message) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    set_has_message();
    type_.message_ = message;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.message)
}
void FieldRules::set_allocated_repeated(::validate::RepeatedRules* repeated) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (repeated) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      repeated = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.repeated)
}
void FieldRules::set_allocated_map(::validate::MapRules* map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (map) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.map)
}
void FieldRules::set_allocated_any(::validate::AnyRules* any) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (any) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      any = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, any, submessage_arena);
    }
    set_has_any();
    type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.any)
}
void FieldRules::set_allocated_duration(::validate::DurationRules* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
    type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.duration)
}
void FieldRules::set_allocated_timestamp(::validate::TimestampRules* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_type();
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.timestamp)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FieldRules::kFloatFieldNumber;
const int FieldRules::kDoubleFieldNumber;
const int FieldRules::kInt32FieldNumber;
const int FieldRules::kInt64FieldNumber;
const int FieldRules::kUint32FieldNumber;
const int FieldRules::kUint64FieldNumber;
const int FieldRules::kSint32FieldNumber;
const int FieldRules::kSint64FieldNumber;
const int FieldRules::kFixed32FieldNumber;
const int FieldRules::kFixed64FieldNumber;
const int FieldRules::kSfixed32FieldNumber;
const int FieldRules::kSfixed64FieldNumber;
const int FieldRules::kBoolFieldNumber;
const int FieldRules::kStringFieldNumber;
const int FieldRules::kBytesFieldNumber;
const int FieldRules::kEnumFieldNumber;
const int FieldRules::kMessageFieldNumber;
const int FieldRules::kRepeatedFieldNumber;
const int FieldRules::kMapFieldNumber;
const int FieldRules::kAnyFieldNumber;
const int FieldRules::kDurationFieldNumber;
const int FieldRules::kTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FieldRules::FieldRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.FieldRules)
}
FieldRules::FieldRules(const FieldRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_type();
  switch (from.type_case()) {
    case kFloat: {
      mutable_float_()->::validate::FloatRules::MergeFrom(from.float_());
      break;
    }
    case kDouble: {
      mutable_double_()->::validate::DoubleRules::MergeFrom(from.double_());
      break;
    }
    case kInt32: {
      mutable_int32()->::validate::Int32Rules::MergeFrom(from.int32());
      break;
    }
    case kInt64: {
      mutable_int64()->::validate::Int64Rules::MergeFrom(from.int64());
      break;
    }
    case kUint32: {
      mutable_uint32()->::validate::UInt32Rules::MergeFrom(from.uint32());
      break;
    }
    case kUint64: {
      mutable_uint64()->::validate::UInt64Rules::MergeFrom(from.uint64());
      break;
    }
    case kSint32: {
      mutable_sint32()->::validate::SInt32Rules::MergeFrom(from.sint32());
      break;
    }
    case kSint64: {
      mutable_sint64()->::validate::SInt64Rules::MergeFrom(from.sint64());
      break;
    }
    case kFixed32: {
      mutable_fixed32()->::validate::Fixed32Rules::MergeFrom(from.fixed32());
      break;
    }
    case kFixed64: {
      mutable_fixed64()->::validate::Fixed64Rules::MergeFrom(from.fixed64());
      break;
    }
    case kSfixed32: {
      mutable_sfixed32()->::validate::SFixed32Rules::MergeFrom(from.sfixed32());
      break;
    }
    case kSfixed64: {
      mutable_sfixed64()->::validate::SFixed64Rules::MergeFrom(from.sfixed64());
      break;
    }
    case kBool: {
      mutable_bool_()->::validate::BoolRules::MergeFrom(from.bool_());
      break;
    }
    case kString: {
      mutable_string()->::validate::StringRules::MergeFrom(from.string());
      break;
    }
    case kBytes: {
      mutable_bytes()->::validate::BytesRules::MergeFrom(from.bytes());
      break;
    }
    case kEnum: {
      mutable_enum_()->::validate::EnumRules::MergeFrom(from.enum_());
      break;
    }
    case kMessage: {
      mutable_message()->::validate::MessageRules::MergeFrom(from.message());
      break;
    }
    case kRepeated: {
      mutable_repeated()->::validate::RepeatedRules::MergeFrom(from.repeated());
      break;
    }
    case kMap: {
      mutable_map()->::validate::MapRules::MergeFrom(from.map());
      break;
    }
    case kAny: {
      mutable_any()->::validate::AnyRules::MergeFrom(from.any());
      break;
    }
    case kDuration: {
      mutable_duration()->::validate::DurationRules::MergeFrom(from.duration());
      break;
    }
    case kTimestamp: {
      mutable_timestamp()->::validate::TimestampRules::MergeFrom(from.timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.FieldRules)
}

void FieldRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  clear_has_type();
}

FieldRules::~FieldRules() {
  // @@protoc_insertion_point(destructor:validate.FieldRules)
  SharedDtor();
}

void FieldRules::SharedDtor() {
  if (has_type()) {
    clear_type();
  }
}

void FieldRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FieldRules& FieldRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void FieldRules::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:validate.FieldRules)
  switch (type_case()) {
    case kFloat: {
      delete type_.float__;
      break;
    }
    case kDouble: {
      delete type_.double__;
      break;
    }
    case kInt32: {
      delete type_.int32_;
      break;
    }
    case kInt64: {
      delete type_.int64_;
      break;
    }
    case kUint32: {
      delete type_.uint32_;
      break;
    }
    case kUint64: {
      delete type_.uint64_;
      break;
    }
    case kSint32: {
      delete type_.sint32_;
      break;
    }
    case kSint64: {
      delete type_.sint64_;
      break;
    }
    case kFixed32: {
      delete type_.fixed32_;
      break;
    }
    case kFixed64: {
      delete type_.fixed64_;
      break;
    }
    case kSfixed32: {
      delete type_.sfixed32_;
      break;
    }
    case kSfixed64: {
      delete type_.sfixed64_;
      break;
    }
    case kBool: {
      delete type_.bool__;
      break;
    }
    case kString: {
      delete type_.string_;
      break;
    }
    case kBytes: {
      delete type_.bytes_;
      break;
    }
    case kEnum: {
      delete type_.enum__;
      break;
    }
    case kMessage: {
      delete type_.message_;
      break;
    }
    case kRepeated: {
      delete type_.repeated_;
      break;
    }
    case kMap: {
      delete type_.map_;
      break;
    }
    case kAny: {
      delete type_.any_;
      break;
    }
    case kDuration: {
      delete type_.duration_;
      break;
    }
    case kTimestamp: {
      delete type_.timestamp_;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void FieldRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FieldRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FieldRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<FieldRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .validate.FloatRules float = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::FloatRules::_InternalParse;
        object = msg->mutable_float_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.DoubleRules double = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::DoubleRules::_InternalParse;
        object = msg->mutable_double_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.Int32Rules int32 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::Int32Rules::_InternalParse;
        object = msg->mutable_int32();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.Int64Rules int64 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::Int64Rules::_InternalParse;
        object = msg->mutable_int64();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.UInt32Rules uint32 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::UInt32Rules::_InternalParse;
        object = msg->mutable_uint32();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.UInt64Rules uint64 = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::UInt64Rules::_InternalParse;
        object = msg->mutable_uint64();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.SInt32Rules sint32 = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::SInt32Rules::_InternalParse;
        object = msg->mutable_sint32();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.SInt64Rules sint64 = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::SInt64Rules::_InternalParse;
        object = msg->mutable_sint64();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.Fixed32Rules fixed32 = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::Fixed32Rules::_InternalParse;
        object = msg->mutable_fixed32();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.Fixed64Rules fixed64 = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::Fixed64Rules::_InternalParse;
        object = msg->mutable_fixed64();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.SFixed32Rules sfixed32 = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::SFixed32Rules::_InternalParse;
        object = msg->mutable_sfixed32();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.SFixed64Rules sfixed64 = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 98) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::SFixed64Rules::_InternalParse;
        object = msg->mutable_sfixed64();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.BoolRules bool = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 106) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::BoolRules::_InternalParse;
        object = msg->mutable_bool_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.StringRules string = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 114) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::StringRules::_InternalParse;
        object = msg->mutable_string();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.BytesRules bytes = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 122) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::BytesRules::_InternalParse;
        object = msg->mutable_bytes();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.EnumRules enum = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 130) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::EnumRules::_InternalParse;
        object = msg->mutable_enum_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.MessageRules message = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 138) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::MessageRules::_InternalParse;
        object = msg->mutable_message();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.RepeatedRules repeated = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 146) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::RepeatedRules::_InternalParse;
        object = msg->mutable_repeated();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.MapRules map = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 154) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::MapRules::_InternalParse;
        object = msg->mutable_map();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.AnyRules any = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 162) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::AnyRules::_InternalParse;
        object = msg->mutable_any();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.DurationRules duration = 21;
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 170) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::DurationRules::_InternalParse;
        object = msg->mutable_duration();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.TimestampRules timestamp = 22;
      case 22: {
        if (static_cast<::google::protobuf::uint8>(tag) != 178) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::TimestampRules::_InternalParse;
        object = msg->mutable_timestamp();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FieldRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.FieldRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .validate.FloatRules float = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_float_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.DoubleRules double = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_double_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.Int32Rules int32 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_int32()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.Int64Rules int64 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_int64()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.UInt32Rules uint32 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_uint32()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.UInt64Rules uint64 = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_uint64()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.SInt32Rules sint32 = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_sint32()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.SInt64Rules sint64 = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_sint64()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.Fixed32Rules fixed32 = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fixed32()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.Fixed64Rules fixed64 = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (82 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fixed64()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.SFixed32Rules sfixed32 = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_sfixed32()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.SFixed64Rules sfixed64 = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (98 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_sfixed64()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.BoolRules bool = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (106 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bool_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.StringRules string = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (114 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_string()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.BytesRules bytes = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (122 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bytes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.EnumRules enum = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (130 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_enum_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.MessageRules message = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (138 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.RepeatedRules repeated = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (146 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_repeated()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.MapRules map = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (154 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_map()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.AnyRules any = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (162 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_any()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.DurationRules duration = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (170 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.TimestampRules timestamp = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (178 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.FieldRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.FieldRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FieldRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.FieldRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kFloat:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        1, HasBitSetters::float_(this), output);
      break;
    case kDouble:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, HasBitSetters::double_(this), output);
      break;
    case kInt32:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, HasBitSetters::int32(this), output);
      break;
    case kInt64:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        4, HasBitSetters::int64(this), output);
      break;
    case kUint32:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        5, HasBitSetters::uint32(this), output);
      break;
    case kUint64:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        6, HasBitSetters::uint64(this), output);
      break;
    case kSint32:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        7, HasBitSetters::sint32(this), output);
      break;
    case kSint64:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        8, HasBitSetters::sint64(this), output);
      break;
    case kFixed32:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        9, HasBitSetters::fixed32(this), output);
      break;
    case kFixed64:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        10, HasBitSetters::fixed64(this), output);
      break;
    case kSfixed32:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        11, HasBitSetters::sfixed32(this), output);
      break;
    case kSfixed64:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        12, HasBitSetters::sfixed64(this), output);
      break;
    case kBool:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        13, HasBitSetters::bool_(this), output);
      break;
    case kString:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        14, HasBitSetters::string(this), output);
      break;
    case kBytes:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        15, HasBitSetters::bytes(this), output);
      break;
    case kEnum:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        16, HasBitSetters::enum_(this), output);
      break;
    case kMessage:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        17, HasBitSetters::message(this), output);
      break;
    case kRepeated:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        18, HasBitSetters::repeated(this), output);
      break;
    case kMap:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        19, HasBitSetters::map(this), output);
      break;
    case kAny:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        20, HasBitSetters::any(this), output);
      break;
    case kDuration:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        21, HasBitSetters::duration(this), output);
      break;
    case kTimestamp:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        22, HasBitSetters::timestamp(this), output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.FieldRules)
}

::google::protobuf::uint8* FieldRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.FieldRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kFloat:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          1, HasBitSetters::float_(this), target);
      break;
    case kDouble:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          2, HasBitSetters::double_(this), target);
      break;
    case kInt32:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          3, HasBitSetters::int32(this), target);
      break;
    case kInt64:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          4, HasBitSetters::int64(this), target);
      break;
    case kUint32:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          5, HasBitSetters::uint32(this), target);
      break;
    case kUint64:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          6, HasBitSetters::uint64(this), target);
      break;
    case kSint32:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          7, HasBitSetters::sint32(this), target);
      break;
    case kSint64:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          8, HasBitSetters::sint64(this), target);
      break;
    case kFixed32:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          9, HasBitSetters::fixed32(this), target);
      break;
    case kFixed64:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          10, HasBitSetters::fixed64(this), target);
      break;
    case kSfixed32:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          11, HasBitSetters::sfixed32(this), target);
      break;
    case kSfixed64:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          12, HasBitSetters::sfixed64(this), target);
      break;
    case kBool:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          13, HasBitSetters::bool_(this), target);
      break;
    case kString:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          14, HasBitSetters::string(this), target);
      break;
    case kBytes:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          15, HasBitSetters::bytes(this), target);
      break;
    case kEnum:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          16, HasBitSetters::enum_(this), target);
      break;
    case kMessage:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          17, HasBitSetters::message(this), target);
      break;
    case kRepeated:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          18, HasBitSetters::repeated(this), target);
      break;
    case kMap:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          19, HasBitSetters::map(this), target);
      break;
    case kAny:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          20, HasBitSetters::any(this), target);
      break;
    case kDuration:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          21, HasBitSetters::duration(this), target);
      break;
    case kTimestamp:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          22, HasBitSetters::timestamp(this), target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FieldRules)
  return target;
}

size_t FieldRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.FieldRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_case()) {
    // optional .validate.FloatRules float = 1;
    case kFloat: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.float__);
      break;
    }
    // optional .validate.DoubleRules double = 2;
    case kDouble: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.double__);
      break;
    }
    // optional .validate.Int32Rules int32 = 3;
    case kInt32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.int32_);
      break;
    }
    // optional .validate.Int64Rules int64 = 4;
    case kInt64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.int64_);
      break;
    }
    // optional .validate.UInt32Rules uint32 = 5;
    case kUint32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.uint32_);
      break;
    }
    // optional .validate.UInt64Rules uint64 = 6;
    case kUint64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.uint64_);
      break;
    }
    // optional .validate.SInt32Rules sint32 = 7;
    case kSint32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.sint32_);
      break;
    }
    // optional .validate.SInt64Rules sint64 = 8;
    case kSint64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.sint64_);
      break;
    }
    // optional .validate.Fixed32Rules fixed32 = 9;
    case kFixed32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.fixed32_);
      break;
    }
    // optional .validate.Fixed64Rules fixed64 = 10;
    case kFixed64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.fixed64_);
      break;
    }
    // optional .validate.SFixed32Rules sfixed32 = 11;
    case kSfixed32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.sfixed32_);
      break;
    }
    // optional .validate.SFixed64Rules sfixed64 = 12;
    case kSfixed64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.sfixed64_);
      break;
    }
    // optional .validate.BoolRules bool = 13;
    case kBool: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.bool__);
      break;
    }
    // optional .validate.StringRules string = 14;
    case kString: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.string_);
      break;
    }
    // optional .validate.BytesRules bytes = 15;
    case kBytes: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.bytes_);
      break;
    }
    // optional .validate.EnumRules enum = 16;
    case kEnum: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.enum__);
      break;
    }
    // optional .validate.MessageRules message = 17;
    case kMessage: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.message_);
      break;
    }
    // optional .validate.RepeatedRules repeated = 18;
    case kRepeated: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.repeated_);
      break;
    }
    // optional .validate.MapRules map = 19;
    case kMap: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.map_);
      break;
    }
    // optional .validate.AnyRules any = 20;
    case kAny: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.any_);
      break;
    }
    // optional .validate.DurationRules duration = 21;
    case kDuration: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.duration_);
      break;
    }
    // optional .validate.TimestampRules timestamp = 22;
    case kTimestamp: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FieldRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.FieldRules)
  GOOGLE_DCHECK_NE(&from, this);
  const FieldRules* source =
      ::google::protobuf::DynamicCastToGenerated<FieldRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.FieldRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.FieldRules)
    MergeFrom(*source);
  }
}

void FieldRules::MergeFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.FieldRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_case()) {
    case kFloat: {
      mutable_float_()->::validate::FloatRules::MergeFrom(from.float_());
      break;
    }
    case kDouble: {
      mutable_double_()->::validate::DoubleRules::MergeFrom(from.double_());
      break;
    }
    case kInt32: {
      mutable_int32()->::validate::Int32Rules::MergeFrom(from.int32());
      break;
    }
    case kInt64: {
      mutable_int64()->::validate::Int64Rules::MergeFrom(from.int64());
      break;
    }
    case kUint32: {
      mutable_uint32()->::validate::UInt32Rules::MergeFrom(from.uint32());
      break;
    }
    case kUint64: {
      mutable_uint64()->::validate::UInt64Rules::MergeFrom(from.uint64());
      break;
    }
    case kSint32: {
      mutable_sint32()->::validate::SInt32Rules::MergeFrom(from.sint32());
      break;
    }
    case kSint64: {
      mutable_sint64()->::validate::SInt64Rules::MergeFrom(from.sint64());
      break;
    }
    case kFixed32: {
      mutable_fixed32()->::validate::Fixed32Rules::MergeFrom(from.fixed32());
      break;
    }
    case kFixed64: {
      mutable_fixed64()->::validate::Fixed64Rules::MergeFrom(from.fixed64());
      break;
    }
    case kSfixed32: {
      mutable_sfixed32()->::validate::SFixed32Rules::MergeFrom(from.sfixed32());
      break;
    }
    case kSfixed64: {
      mutable_sfixed64()->::validate::SFixed64Rules::MergeFrom(from.sfixed64());
      break;
    }
    case kBool: {
      mutable_bool_()->::validate::BoolRules::MergeFrom(from.bool_());
      break;
    }
    case kString: {
      mutable_string()->::validate::StringRules::MergeFrom(from.string());
      break;
    }
    case kBytes: {
      mutable_bytes()->::validate::BytesRules::MergeFrom(from.bytes());
      break;
    }
    case kEnum: {
      mutable_enum_()->::validate::EnumRules::MergeFrom(from.enum_());
      break;
    }
    case kMessage: {
      mutable_message()->::validate::MessageRules::MergeFrom(from.message());
      break;
    }
    case kRepeated: {
      mutable_repeated()->::validate::RepeatedRules::MergeFrom(from.repeated());
      break;
    }
    case kMap: {
      mutable_map()->::validate::MapRules::MergeFrom(from.map());
      break;
    }
    case kAny: {
      mutable_any()->::validate::AnyRules::MergeFrom(from.any());
      break;
    }
    case kDuration: {
      mutable_duration()->::validate::DurationRules::MergeFrom(from.duration());
      break;
    }
    case kTimestamp: {
      mutable_timestamp()->::validate::TimestampRules::MergeFrom(from.timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
}

void FieldRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldRules::CopyFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldRules::IsInitialized() const {
  return true;
}

void FieldRules::Swap(FieldRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FieldRules::InternalSwap(FieldRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata FieldRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void FloatRules::InitAsDefaultInstance() {
}
class FloatRules::HasBitSetters {
 public:
  static void set_has_const_(FloatRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(FloatRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(FloatRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(FloatRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(FloatRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FloatRules::kConstFieldNumber;
const int FloatRules::kLtFieldNumber;
const int FloatRules::kLteFieldNumber;
const int FloatRules::kGtFieldNumber;
const int FloatRules::kGteFieldNumber;
const int FloatRules::kInFieldNumber;
const int FloatRules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FloatRules::FloatRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.FloatRules)
}
FloatRules::FloatRules(const FloatRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.FloatRules)
}

void FloatRules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:validate.FloatRules)
  SharedDtor();
}

void FloatRules::SharedDtor() {
}

void FloatRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FloatRules& FloatRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FloatRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FloatRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FloatRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<FloatRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional float const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_const_(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_lt(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_lte(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_gt(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_gte(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // repeated float in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 53) {
          do {
            msg->add_in(::google::protobuf::io::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 53 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFloatParser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated float not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 61) {
          do {
            msg->add_not_in(::google::protobuf::io::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 61 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFloatParser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FloatRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.FloatRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 53u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 61u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.FloatRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.FloatRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FloatRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.FloatRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->const_(), output);
  }

  // optional float lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->lt(), output);
  }

  // optional float lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->lte(), output);
  }

  // optional float gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->gt(), output);
  }

  // optional float gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->gte(), output);
  }

  // repeated float in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      6, this->in(i), output);
  }

  // repeated float not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.FloatRules)
}

::google::protobuf::uint8* FloatRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.FloatRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->const_(), target);
  }

  // optional float lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->lt(), target);
  }

  // optional float lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->lte(), target);
  }

  // optional float gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->gt(), target);
  }

  // optional float gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->gte(), target);
  }

  // repeated float in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFloatToArray(6, this->in_, target);

  // repeated float not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFloatToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FloatRules)
  return target;
}

size_t FloatRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.FloatRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated float not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloatRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.FloatRules)
  GOOGLE_DCHECK_NE(&from, this);
  const FloatRules* source =
      ::google::protobuf::DynamicCastToGenerated<FloatRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.FloatRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.FloatRules)
    MergeFrom(*source);
  }
}

void FloatRules::MergeFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.FloatRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FloatRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatRules::IsInitialized() const {
  return true;
}

void FloatRules::Swap(FloatRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FloatRules::InternalSwap(FloatRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata FloatRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void DoubleRules::InitAsDefaultInstance() {
}
class DoubleRules::HasBitSetters {
 public:
  static void set_has_const_(DoubleRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(DoubleRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(DoubleRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(DoubleRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(DoubleRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DoubleRules::kConstFieldNumber;
const int DoubleRules::kLtFieldNumber;
const int DoubleRules::kLteFieldNumber;
const int DoubleRules::kGtFieldNumber;
const int DoubleRules::kGteFieldNumber;
const int DoubleRules::kInFieldNumber;
const int DoubleRules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DoubleRules::DoubleRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.DoubleRules)
}
DoubleRules::DoubleRules(const DoubleRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.DoubleRules)
}

void DoubleRules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:validate.DoubleRules)
  SharedDtor();
}

void DoubleRules::SharedDtor() {
}

void DoubleRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DoubleRules& DoubleRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_DoubleRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DoubleRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DoubleRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<DoubleRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_const_(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_lt(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_lte(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_gt(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_gte(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // repeated double in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 49) {
          do {
            msg->add_in(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 49 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated double not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 57) {
          do {
            msg->add_not_in(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 57 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DoubleRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.DoubleRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 49u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 57u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.DoubleRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.DoubleRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DoubleRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.DoubleRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->const_(), output);
  }

  // optional double lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->lt(), output);
  }

  // optional double lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->lte(), output);
  }

  // optional double gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->gt(), output);
  }

  // optional double gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->gte(), output);
  }

  // repeated double in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      6, this->in(i), output);
  }

  // repeated double not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.DoubleRules)
}

::google::protobuf::uint8* DoubleRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.DoubleRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->const_(), target);
  }

  // optional double lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->lt(), target);
  }

  // optional double lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->lte(), target);
  }

  // optional double gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->gt(), target);
  }

  // optional double gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->gte(), target);
  }

  // repeated double in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(6, this->in_, target);

  // repeated double not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DoubleRules)
  return target;
}

size_t DoubleRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.DoubleRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated double not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional double const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DoubleRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.DoubleRules)
  GOOGLE_DCHECK_NE(&from, this);
  const DoubleRules* source =
      ::google::protobuf::DynamicCastToGenerated<DoubleRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.DoubleRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.DoubleRules)
    MergeFrom(*source);
  }
}

void DoubleRules::MergeFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.DoubleRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DoubleRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleRules::IsInitialized() const {
  return true;
}

void DoubleRules::Swap(DoubleRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DoubleRules::InternalSwap(DoubleRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata DoubleRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Int32Rules::InitAsDefaultInstance() {
}
class Int32Rules::HasBitSetters {
 public:
  static void set_has_const_(Int32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(Int32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(Int32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(Int32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(Int32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int32Rules::kConstFieldNumber;
const int Int32Rules::kLtFieldNumber;
const int Int32Rules::kLteFieldNumber;
const int Int32Rules::kGtFieldNumber;
const int Int32Rules::kGteFieldNumber;
const int Int32Rules::kInFieldNumber;
const int Int32Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int32Rules::Int32Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.Int32Rules)
}
Int32Rules::Int32Rules(const Int32Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Int32Rules)
}

void Int32Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:validate.Int32Rules)
  SharedDtor();
}

void Int32Rules::SharedDtor() {
}

void Int32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Int32Rules& Int32Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Int32Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Int32Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Int32Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int32 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_lt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_lte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_gt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_gte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated int32 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 48) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 48 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedInt32Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated int32 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 56) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 56 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedInt32Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Int32Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.Int32Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 56u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.Int32Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.Int32Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Int32Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.Int32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->const_(), output);
  }

  // optional int32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lt(), output);
  }

  // optional int32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lte(), output);
  }

  // optional int32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gt(), output);
  }

  // optional int32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->gte(), output);
  }

  // repeated int32 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->in(i), output);
  }

  // repeated int32 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.Int32Rules)
}

::google::protobuf::uint8* Int32Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->const_(), target);
  }

  // optional int32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lt(), target);
  }

  // optional int32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lte(), target);
  }

  // optional int32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->gt(), target);
  }

  // optional int32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->gte(), target);
  }

  // repeated int32 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(6, this->in_, target);

  // repeated int32 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int32Rules)
  return target;
}

size_t Int32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Int32Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 7;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->const_());
    }

    // optional int32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lt());
    }

    // optional int32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lte());
    }

    // optional int32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gt());
    }

    // optional int32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gte());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int32Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.Int32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Int32Rules* source =
      ::google::protobuf::DynamicCastToGenerated<Int32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.Int32Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.Int32Rules)
    MergeFrom(*source);
  }
}

void Int32Rules::MergeFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Int32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Int32Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int32Rules::IsInitialized() const {
  return true;
}

void Int32Rules::Swap(Int32Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int32Rules::InternalSwap(Int32Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata Int32Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Int64Rules::InitAsDefaultInstance() {
}
class Int64Rules::HasBitSetters {
 public:
  static void set_has_const_(Int64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(Int64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(Int64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(Int64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(Int64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64Rules::kConstFieldNumber;
const int Int64Rules::kLtFieldNumber;
const int Int64Rules::kLteFieldNumber;
const int Int64Rules::kGtFieldNumber;
const int Int64Rules::kGteFieldNumber;
const int Int64Rules::kInFieldNumber;
const int Int64Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64Rules::Int64Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.Int64Rules)
}
Int64Rules::Int64Rules(const Int64Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Int64Rules)
}

void Int64Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:validate.Int64Rules)
  SharedDtor();
}

void Int64Rules::SharedDtor() {
}

void Int64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Int64Rules& Int64Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Int64Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Int64Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Int64Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int64 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int64 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_lt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int64 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_lte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int64 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_gt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int64 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_gte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated int64 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 48) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 48 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedInt64Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated int64 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 56) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 56 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedInt64Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Int64Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.Int64Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int64 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 48u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int64 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 56u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.Int64Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.Int64Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Int64Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.Int64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->const_(), output);
  }

  // optional int64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->lt(), output);
  }

  // optional int64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->lte(), output);
  }

  // optional int64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->gt(), output);
  }

  // optional int64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->gte(), output);
  }

  // repeated int64 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      6, this->in(i), output);
  }

  // repeated int64 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.Int64Rules)
}

::google::protobuf::uint8* Int64Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->const_(), target);
  }

  // optional int64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->lt(), target);
  }

  // optional int64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->lte(), target);
  }

  // optional int64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->gt(), target);
  }

  // optional int64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->gte(), target);
  }

  // repeated int64 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt64ToArray(6, this->in_, target);

  // repeated int64 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt64ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int64Rules)
  return target;
}

size_t Int64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Int64Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 in = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated int64 not_in = 7;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->const_());
    }

    // optional int64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->lt());
    }

    // optional int64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->lte());
    }

    // optional int64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gt());
    }

    // optional int64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gte());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.Int64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Int64Rules* source =
      ::google::protobuf::DynamicCastToGenerated<Int64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.Int64Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.Int64Rules)
    MergeFrom(*source);
  }
}

void Int64Rules::MergeFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Int64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Int64Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Rules::IsInitialized() const {
  return true;
}

void Int64Rules::Swap(Int64Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64Rules::InternalSwap(Int64Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata Int64Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void UInt32Rules::InitAsDefaultInstance() {
}
class UInt32Rules::HasBitSetters {
 public:
  static void set_has_const_(UInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(UInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(UInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(UInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(UInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UInt32Rules::kConstFieldNumber;
const int UInt32Rules::kLtFieldNumber;
const int UInt32Rules::kLteFieldNumber;
const int UInt32Rules::kGtFieldNumber;
const int UInt32Rules::kGteFieldNumber;
const int UInt32Rules::kInFieldNumber;
const int UInt32Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UInt32Rules::UInt32Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.UInt32Rules)
}
UInt32Rules::UInt32Rules(const UInt32Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.UInt32Rules)
}

void UInt32Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt32Rules)
  SharedDtor();
}

void UInt32Rules::SharedDtor() {
}

void UInt32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UInt32Rules& UInt32Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_UInt32Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UInt32Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<UInt32Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_lt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_lte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_gt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_gte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated uint32 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 48) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 48 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated uint32 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 56) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 56 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UInt32Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.UInt32Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.UInt32Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.UInt32Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UInt32Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.UInt32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->const_(), output);
  }

  // optional uint32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->lt(), output);
  }

  // optional uint32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->lte(), output);
  }

  // optional uint32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->gt(), output);
  }

  // optional uint32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->gte(), output);
  }

  // repeated uint32 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->in(i), output);
  }

  // repeated uint32 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.UInt32Rules)
}

::google::protobuf::uint8* UInt32Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->const_(), target);
  }

  // optional uint32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->lt(), target);
  }

  // optional uint32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->lte(), target);
  }

  // optional uint32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->gt(), target);
  }

  // optional uint32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->gte(), target);
  }

  // repeated uint32 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(6, this->in_, target);

  // repeated uint32 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt32Rules)
  return target;
}

size_t UInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.UInt32Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 in = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated uint32 not_in = 7;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->const_());
    }

    // optional uint32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lt());
    }

    // optional uint32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lte());
    }

    // optional uint32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gt());
    }

    // optional uint32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gte());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UInt32Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.UInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const UInt32Rules* source =
      ::google::protobuf::DynamicCastToGenerated<UInt32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.UInt32Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.UInt32Rules)
    MergeFrom(*source);
  }
}

void UInt32Rules::MergeFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UInt32Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt32Rules::IsInitialized() const {
  return true;
}

void UInt32Rules::Swap(UInt32Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UInt32Rules::InternalSwap(UInt32Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata UInt32Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void UInt64Rules::InitAsDefaultInstance() {
}
class UInt64Rules::HasBitSetters {
 public:
  static void set_has_const_(UInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(UInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(UInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(UInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(UInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UInt64Rules::kConstFieldNumber;
const int UInt64Rules::kLtFieldNumber;
const int UInt64Rules::kLteFieldNumber;
const int UInt64Rules::kGtFieldNumber;
const int UInt64Rules::kGteFieldNumber;
const int UInt64Rules::kInFieldNumber;
const int UInt64Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UInt64Rules::UInt64Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.UInt64Rules)
}
UInt64Rules::UInt64Rules(const UInt64Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.UInt64Rules)
}

void UInt64Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt64Rules)
  SharedDtor();
}

void UInt64Rules::SharedDtor() {
}

void UInt64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UInt64Rules& UInt64Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_UInt64Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UInt64Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<UInt64Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_lt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_lte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_gt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_gte(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated uint64 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 48) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 48 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt64Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated uint64 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 56) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 56 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt64Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UInt64Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.UInt64Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint64 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 48u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint64 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 56u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.UInt64Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.UInt64Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UInt64Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.UInt64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->const_(), output);
  }

  // optional uint64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->lt(), output);
  }

  // optional uint64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->lte(), output);
  }

  // optional uint64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->gt(), output);
  }

  // optional uint64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->gte(), output);
  }

  // repeated uint64 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      6, this->in(i), output);
  }

  // repeated uint64 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.UInt64Rules)
}

::google::protobuf::uint8* UInt64Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->const_(), target);
  }

  // optional uint64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->lt(), target);
  }

  // optional uint64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->lte(), target);
  }

  // optional uint64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->gt(), target);
  }

  // optional uint64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->gte(), target);
  }

  // repeated uint64 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt64ToArray(6, this->in_, target);

  // repeated uint64 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt64ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt64Rules)
  return target;
}

size_t UInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.UInt64Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 in = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt64Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated uint64 not_in = 7;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt64Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->const_());
    }

    // optional uint64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lt());
    }

    // optional uint64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lte());
    }

    // optional uint64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->gt());
    }

    // optional uint64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->gte());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UInt64Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.UInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const UInt64Rules* source =
      ::google::protobuf::DynamicCastToGenerated<UInt64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.UInt64Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.UInt64Rules)
    MergeFrom(*source);
  }
}

void UInt64Rules::MergeFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UInt64Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt64Rules::IsInitialized() const {
  return true;
}

void UInt64Rules::Swap(UInt64Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UInt64Rules::InternalSwap(UInt64Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata UInt64Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SInt32Rules::InitAsDefaultInstance() {
}
class SInt32Rules::HasBitSetters {
 public:
  static void set_has_const_(SInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(SInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(SInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(SInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(SInt32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SInt32Rules::kConstFieldNumber;
const int SInt32Rules::kLtFieldNumber;
const int SInt32Rules::kLteFieldNumber;
const int SInt32Rules::kGtFieldNumber;
const int SInt32Rules::kGteFieldNumber;
const int SInt32Rules::kInFieldNumber;
const int SInt32Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SInt32Rules::SInt32Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.SInt32Rules)
}
SInt32Rules::SInt32Rules(const SInt32Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SInt32Rules)
}

void SInt32Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt32Rules)
  SharedDtor();
}

void SInt32Rules::SharedDtor() {
}

void SInt32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SInt32Rules& SInt32Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SInt32Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SInt32Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SInt32Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional sint32 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint32 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_lt(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint32 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_lte(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint32 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_gt(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint32 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_gte(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated sint32 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 48) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 48 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSInt32Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated sint32 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 56) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 56 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSInt32Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SInt32Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.SInt32Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sint32 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 48u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sint32 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 1, 56u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.SInt32Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.SInt32Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SInt32Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.SInt32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->const_(), output);
  }

  // optional sint32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->lt(), output);
  }

  // optional sint32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->lte(), output);
  }

  // optional sint32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->gt(), output);
  }

  // optional sint32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->gte(), output);
  }

  // repeated sint32 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(
      6, this->in(i), output);
  }

  // repeated sint32 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.SInt32Rules)
}

::google::protobuf::uint8* SInt32Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->const_(), target);
  }

  // optional sint32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->lt(), target);
  }

  // optional sint32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->lte(), target);
  }

  // optional sint32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->gt(), target);
  }

  // optional sint32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->gte(), target);
  }

  // repeated sint32 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSInt32ToArray(6, this->in_, target);

  // repeated sint32 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSInt32ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt32Rules)
  return target;
}

size_t SInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SInt32Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint32 in = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      SInt32Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated sint32 not_in = 7;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      SInt32Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sint32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->const_());
    }

    // optional sint32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->lt());
    }

    // optional sint32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->lte());
    }

    // optional sint32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->gt());
    }

    // optional sint32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->gte());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SInt32Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.SInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SInt32Rules* source =
      ::google::protobuf::DynamicCastToGenerated<SInt32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.SInt32Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.SInt32Rules)
    MergeFrom(*source);
  }
}

void SInt32Rules::MergeFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SInt32Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt32Rules::IsInitialized() const {
  return true;
}

void SInt32Rules::Swap(SInt32Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SInt32Rules::InternalSwap(SInt32Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata SInt32Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SInt64Rules::InitAsDefaultInstance() {
}
class SInt64Rules::HasBitSetters {
 public:
  static void set_has_const_(SInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(SInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(SInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(SInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(SInt64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SInt64Rules::kConstFieldNumber;
const int SInt64Rules::kLtFieldNumber;
const int SInt64Rules::kLteFieldNumber;
const int SInt64Rules::kGtFieldNumber;
const int SInt64Rules::kGteFieldNumber;
const int SInt64Rules::kInFieldNumber;
const int SInt64Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SInt64Rules::SInt64Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.SInt64Rules)
}
SInt64Rules::SInt64Rules(const SInt64Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SInt64Rules)
}

void SInt64Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt64Rules)
  SharedDtor();
}

void SInt64Rules::SharedDtor() {
}

void SInt64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SInt64Rules& SInt64Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SInt64Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SInt64Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SInt64Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional sint64 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint64 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_lt(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint64 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_lte(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint64 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_gt(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional sint64 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_gte(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated sint64 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 48) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 48 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSInt64Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated sint64 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 56) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarintZigZag64(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 56 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSInt64Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SInt64Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.SInt64Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint64 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint64 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint64 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint64 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint64 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sint64 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 1, 48u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sint64 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 1, 56u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.SInt64Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.SInt64Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SInt64Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.SInt64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(1, this->const_(), output);
  }

  // optional sint64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(2, this->lt(), output);
  }

  // optional sint64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(3, this->lte(), output);
  }

  // optional sint64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(4, this->gt(), output);
  }

  // optional sint64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(5, this->gte(), output);
  }

  // repeated sint64 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(
      6, this->in(i), output);
  }

  // repeated sint64 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.SInt64Rules)
}

::google::protobuf::uint8* SInt64Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(1, this->const_(), target);
  }

  // optional sint64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(2, this->lt(), target);
  }

  // optional sint64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(3, this->lte(), target);
  }

  // optional sint64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(4, this->gt(), target);
  }

  // optional sint64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(5, this->gte(), target);
  }

  // repeated sint64 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSInt64ToArray(6, this->in_, target);

  // repeated sint64 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSInt64ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt64Rules)
  return target;
}

size_t SInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SInt64Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint64 in = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      SInt64Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated sint64 not_in = 7;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      SInt64Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sint64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->const_());
    }

    // optional sint64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->lt());
    }

    // optional sint64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->lte());
    }

    // optional sint64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->gt());
    }

    // optional sint64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->gte());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SInt64Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.SInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SInt64Rules* source =
      ::google::protobuf::DynamicCastToGenerated<SInt64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.SInt64Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.SInt64Rules)
    MergeFrom(*source);
  }
}

void SInt64Rules::MergeFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SInt64Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt64Rules::IsInitialized() const {
  return true;
}

void SInt64Rules::Swap(SInt64Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SInt64Rules::InternalSwap(SInt64Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata SInt64Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Fixed32Rules::InitAsDefaultInstance() {
}
class Fixed32Rules::HasBitSetters {
 public:
  static void set_has_const_(Fixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(Fixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(Fixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(Fixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(Fixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Fixed32Rules::kConstFieldNumber;
const int Fixed32Rules::kLtFieldNumber;
const int Fixed32Rules::kLteFieldNumber;
const int Fixed32Rules::kGtFieldNumber;
const int Fixed32Rules::kGteFieldNumber;
const int Fixed32Rules::kInFieldNumber;
const int Fixed32Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Fixed32Rules::Fixed32Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.Fixed32Rules)
}
Fixed32Rules::Fixed32Rules(const Fixed32Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Fixed32Rules)
}

void Fixed32Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed32Rules)
  SharedDtor();
}

void Fixed32Rules::SharedDtor() {
}

void Fixed32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Fixed32Rules& Fixed32Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Fixed32Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Fixed32Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Fixed32Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional fixed32 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_const_(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed32 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_lt(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed32 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_lte(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed32 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_gt(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed32 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_gte(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // repeated fixed32 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 53) {
          do {
            msg->add_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
            ptr += sizeof(::google::protobuf::uint32);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 53 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFixed32Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated fixed32 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 61) {
          do {
            msg->add_not_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
            ptr += sizeof(::google::protobuf::uint32);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 61 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFixed32Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Fixed32Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.Fixed32Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed32 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated fixed32 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 53u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated fixed32 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 61u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.Fixed32Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.Fixed32Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Fixed32Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.Fixed32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->const_(), output);
  }

  // optional fixed32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->lt(), output);
  }

  // optional fixed32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->lte(), output);
  }

  // optional fixed32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->gt(), output);
  }

  // optional fixed32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(5, this->gte(), output);
  }

  // repeated fixed32 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      6, this->in(i), output);
  }

  // repeated fixed32 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.Fixed32Rules)
}

::google::protobuf::uint8* Fixed32Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(1, this->const_(), target);
  }

  // optional fixed32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(2, this->lt(), target);
  }

  // optional fixed32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(3, this->lte(), target);
  }

  // optional fixed32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->gt(), target);
  }

  // optional fixed32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(5, this->gte(), target);
  }

  // repeated fixed32 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFixed32ToArray(6, this->in_, target);

  // repeated fixed32 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFixed32ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed32Rules)
  return target;
}

size_t Fixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Fixed32Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated fixed32 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional fixed32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional fixed32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fixed32Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.Fixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Fixed32Rules* source =
      ::google::protobuf::DynamicCastToGenerated<Fixed32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.Fixed32Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.Fixed32Rules)
    MergeFrom(*source);
  }
}

void Fixed32Rules::MergeFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Fixed32Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed32Rules::IsInitialized() const {
  return true;
}

void Fixed32Rules::Swap(Fixed32Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Fixed32Rules::InternalSwap(Fixed32Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata Fixed32Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Fixed64Rules::InitAsDefaultInstance() {
}
class Fixed64Rules::HasBitSetters {
 public:
  static void set_has_const_(Fixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(Fixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(Fixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(Fixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(Fixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Fixed64Rules::kConstFieldNumber;
const int Fixed64Rules::kLtFieldNumber;
const int Fixed64Rules::kLteFieldNumber;
const int Fixed64Rules::kGtFieldNumber;
const int Fixed64Rules::kGteFieldNumber;
const int Fixed64Rules::kInFieldNumber;
const int Fixed64Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Fixed64Rules::Fixed64Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.Fixed64Rules)
}
Fixed64Rules::Fixed64Rules(const Fixed64Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Fixed64Rules)
}

void Fixed64Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed64Rules)
  SharedDtor();
}

void Fixed64Rules::SharedDtor() {
}

void Fixed64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Fixed64Rules& Fixed64Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Fixed64Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Fixed64Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Fixed64Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional fixed64 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_const_(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional fixed64 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_lt(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional fixed64 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_lte(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional fixed64 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_gt(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional fixed64 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_gte(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // repeated fixed64 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 49) {
          do {
            msg->add_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
            ptr += sizeof(::google::protobuf::uint64);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 49 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFixed64Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated fixed64 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 57) {
          do {
            msg->add_not_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
            ptr += sizeof(::google::protobuf::uint64);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 57 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedFixed64Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Fixed64Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.Fixed64Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated fixed64 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 1, 49u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated fixed64 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 1, 57u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.Fixed64Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.Fixed64Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Fixed64Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.Fixed64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->const_(), output);
  }

  // optional fixed64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(2, this->lt(), output);
  }

  // optional fixed64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(3, this->lte(), output);
  }

  // optional fixed64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(4, this->gt(), output);
  }

  // optional fixed64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->gte(), output);
  }

  // repeated fixed64 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(
      6, this->in(i), output);
  }

  // repeated fixed64 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.Fixed64Rules)
}

::google::protobuf::uint8* Fixed64Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->const_(), target);
  }

  // optional fixed64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(2, this->lt(), target);
  }

  // optional fixed64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(3, this->lte(), target);
  }

  // optional fixed64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(4, this->gt(), target);
  }

  // optional fixed64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(5, this->gte(), target);
  }

  // repeated fixed64 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFixed64ToArray(6, this->in_, target);

  // repeated fixed64 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFixed64ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed64Rules)
  return target;
}

size_t Fixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Fixed64Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated fixed64 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional fixed64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional fixed64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fixed64Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.Fixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Fixed64Rules* source =
      ::google::protobuf::DynamicCastToGenerated<Fixed64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.Fixed64Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.Fixed64Rules)
    MergeFrom(*source);
  }
}

void Fixed64Rules::MergeFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Fixed64Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed64Rules::IsInitialized() const {
  return true;
}

void Fixed64Rules::Swap(Fixed64Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Fixed64Rules::InternalSwap(Fixed64Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata Fixed64Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SFixed32Rules::InitAsDefaultInstance() {
}
class SFixed32Rules::HasBitSetters {
 public:
  static void set_has_const_(SFixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(SFixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(SFixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(SFixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(SFixed32Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SFixed32Rules::kConstFieldNumber;
const int SFixed32Rules::kLtFieldNumber;
const int SFixed32Rules::kLteFieldNumber;
const int SFixed32Rules::kGtFieldNumber;
const int SFixed32Rules::kGteFieldNumber;
const int SFixed32Rules::kInFieldNumber;
const int SFixed32Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SFixed32Rules::SFixed32Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.SFixed32Rules)
}
SFixed32Rules::SFixed32Rules(const SFixed32Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SFixed32Rules)
}

void SFixed32Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed32Rules)
  SharedDtor();
}

void SFixed32Rules::SharedDtor() {
}

void SFixed32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SFixed32Rules& SFixed32Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SFixed32Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SFixed32Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SFixed32Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional sfixed32 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        msg->set_const_(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
        ptr += sizeof(::google::protobuf::int32);
        break;
      }
      // optional sfixed32 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_lt(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
        ptr += sizeof(::google::protobuf::int32);
        break;
      }
      // optional sfixed32 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_lte(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
        ptr += sizeof(::google::protobuf::int32);
        break;
      }
      // optional sfixed32 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_gt(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
        ptr += sizeof(::google::protobuf::int32);
        break;
      }
      // optional sfixed32 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_gte(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
        ptr += sizeof(::google::protobuf::int32);
        break;
      }
      // repeated sfixed32 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 53) {
          do {
            msg->add_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
            ptr += sizeof(::google::protobuf::int32);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 53 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSFixed32Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated sfixed32 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 61) {
          do {
            msg->add_not_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::int32>(ptr));
            ptr += sizeof(::google::protobuf::int32);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 61 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSFixed32Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SFixed32Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.SFixed32Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sfixed32 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed32 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed32 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed32 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed32 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sfixed32 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 1, 53u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sfixed32 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 1, 61u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.SFixed32Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.SFixed32Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SFixed32Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.SFixed32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(1, this->const_(), output);
  }

  // optional sfixed32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(2, this->lt(), output);
  }

  // optional sfixed32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(3, this->lte(), output);
  }

  // optional sfixed32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(4, this->gt(), output);
  }

  // optional sfixed32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(5, this->gte(), output);
  }

  // repeated sfixed32 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(
      6, this->in(i), output);
  }

  // repeated sfixed32 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.SFixed32Rules)
}

::google::protobuf::uint8* SFixed32Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed32Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed32ToArray(1, this->const_(), target);
  }

  // optional sfixed32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed32ToArray(2, this->lt(), target);
  }

  // optional sfixed32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed32ToArray(3, this->lte(), target);
  }

  // optional sfixed32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed32ToArray(4, this->gt(), target);
  }

  // optional sfixed32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed32ToArray(5, this->gte(), target);
  }

  // repeated sfixed32 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSFixed32ToArray(6, this->in_, target);

  // repeated sfixed32 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSFixed32ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed32Rules)
  return target;
}

size_t SFixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SFixed32Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed32 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated sfixed32 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sfixed32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SFixed32Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.SFixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SFixed32Rules* source =
      ::google::protobuf::DynamicCastToGenerated<SFixed32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.SFixed32Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.SFixed32Rules)
    MergeFrom(*source);
  }
}

void SFixed32Rules::MergeFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SFixed32Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed32Rules::IsInitialized() const {
  return true;
}

void SFixed32Rules::Swap(SFixed32Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SFixed32Rules::InternalSwap(SFixed32Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata SFixed32Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SFixed64Rules::InitAsDefaultInstance() {
}
class SFixed64Rules::HasBitSetters {
 public:
  static void set_has_const_(SFixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lt(SFixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lte(SFixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_gt(SFixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_gte(SFixed64Rules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SFixed64Rules::kConstFieldNumber;
const int SFixed64Rules::kLtFieldNumber;
const int SFixed64Rules::kLteFieldNumber;
const int SFixed64Rules::kGtFieldNumber;
const int SFixed64Rules::kGteFieldNumber;
const int SFixed64Rules::kInFieldNumber;
const int SFixed64Rules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SFixed64Rules::SFixed64Rules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.SFixed64Rules)
}
SFixed64Rules::SFixed64Rules(const SFixed64Rules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SFixed64Rules)
}

void SFixed64Rules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gte_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed64Rules)
  SharedDtor();
}

void SFixed64Rules::SharedDtor() {
}

void SFixed64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SFixed64Rules& SFixed64Rules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SFixed64Rules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SFixed64Rules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SFixed64Rules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional sfixed64 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_const_(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
        ptr += sizeof(::google::protobuf::int64);
        break;
      }
      // optional sfixed64 lt = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_lt(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
        ptr += sizeof(::google::protobuf::int64);
        break;
      }
      // optional sfixed64 lte = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_lte(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
        ptr += sizeof(::google::protobuf::int64);
        break;
      }
      // optional sfixed64 gt = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_gt(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
        ptr += sizeof(::google::protobuf::int64);
        break;
      }
      // optional sfixed64 gte = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_gte(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
        ptr += sizeof(::google::protobuf::int64);
        break;
      }
      // repeated sfixed64 in = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) == 49) {
          do {
            msg->add_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
            ptr += sizeof(::google::protobuf::int64);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 49 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSFixed64Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated sfixed64 not_in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) == 57) {
          do {
            msg->add_not_in(::google::protobuf::io::UnalignedLoad<::google::protobuf::int64>(ptr));
            ptr += sizeof(::google::protobuf::int64);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 57 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedSFixed64Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SFixed64Rules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.SFixed64Rules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sfixed64 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed64 lt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_lt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &lt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed64 lte = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_lte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &lte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed64 gt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_gt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &gt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed64 gte = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_gte(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &gte_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sfixed64 in = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 1, 49u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated sfixed64 not_in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 1, 57u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.SFixed64Rules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.SFixed64Rules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SFixed64Rules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.SFixed64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(1, this->const_(), output);
  }

  // optional sfixed64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(2, this->lt(), output);
  }

  // optional sfixed64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(3, this->lte(), output);
  }

  // optional sfixed64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(4, this->gt(), output);
  }

  // optional sfixed64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(5, this->gte(), output);
  }

  // repeated sfixed64 in = 6;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(
      6, this->in(i), output);
  }

  // repeated sfixed64 not_in = 7;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(
      7, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.SFixed64Rules)
}

::google::protobuf::uint8* SFixed64Rules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed64Rules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(1, this->const_(), target);
  }

  // optional sfixed64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(2, this->lt(), target);
  }

  // optional sfixed64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(3, this->lte(), target);
  }

  // optional sfixed64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(4, this->gt(), target);
  }

  // optional sfixed64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(5, this->gte(), target);
  }

  // repeated sfixed64 in = 6;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSFixed64ToArray(6, this->in_, target);

  // repeated sfixed64 not_in = 7;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteSFixed64ToArray(7, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed64Rules)
  return target;
}

size_t SFixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SFixed64Rules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed64 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated sfixed64 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sfixed64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SFixed64Rules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.SFixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SFixed64Rules* source =
      ::google::protobuf::DynamicCastToGenerated<SFixed64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.SFixed64Rules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.SFixed64Rules)
    MergeFrom(*source);
  }
}

void SFixed64Rules::MergeFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SFixed64Rules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed64Rules::IsInitialized() const {
  return true;
}

void SFixed64Rules::Swap(SFixed64Rules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SFixed64Rules::InternalSwap(SFixed64Rules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
}

::google::protobuf::Metadata SFixed64Rules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BoolRules::InitAsDefaultInstance() {
}
class BoolRules::HasBitSetters {
 public:
  static void set_has_const_(BoolRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BoolRules::kConstFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BoolRules::BoolRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.BoolRules)
}
BoolRules::BoolRules(const BoolRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  const__ = from.const__;
  // @@protoc_insertion_point(copy_constructor:validate.BoolRules)
}

void BoolRules::SharedCtor() {
  const__ = false;
}

BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:validate.BoolRules)
  SharedDtor();
}

void BoolRules::SharedDtor() {
}

void BoolRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BoolRules& BoolRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BoolRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BoolRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  const__ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BoolRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BoolRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BoolRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.BoolRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.BoolRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.BoolRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BoolRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.BoolRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->const_(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.BoolRules)
}

::google::protobuf::uint8* BoolRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.BoolRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->const_(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BoolRules)
  return target;
}

size_t BoolRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.BoolRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool const = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BoolRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.BoolRules)
  GOOGLE_DCHECK_NE(&from, this);
  const BoolRules* source =
      ::google::protobuf::DynamicCastToGenerated<BoolRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.BoolRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.BoolRules)
    MergeFrom(*source);
  }
}

void BoolRules::MergeFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.BoolRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_const_()) {
    set_const_(from.const_());
  }
}

void BoolRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolRules::IsInitialized() const {
  return true;
}

void BoolRules::Swap(BoolRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BoolRules::InternalSwap(BoolRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(const__, other->const__);
}

::google::protobuf::Metadata BoolRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void StringRules::InitAsDefaultInstance() {
  ::validate::_StringRules_default_instance_.email_ = false;
  ::validate::_StringRules_default_instance_.hostname_ = false;
  ::validate::_StringRules_default_instance_.ip_ = false;
  ::validate::_StringRules_default_instance_.ipv4_ = false;
  ::validate::_StringRules_default_instance_.ipv6_ = false;
  ::validate::_StringRules_default_instance_.uri_ = false;
  ::validate::_StringRules_default_instance_.uri_ref_ = false;
}
class StringRules::HasBitSetters {
 public:
  static void set_has_const_(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_len(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_min_len(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_max_len(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_len_bytes(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_min_bytes(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_max_bytes(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_pattern(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_prefix(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_suffix(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_contains(StringRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringRules::kConstFieldNumber;
const int StringRules::kLenFieldNumber;
const int StringRules::kMinLenFieldNumber;
const int StringRules::kMaxLenFieldNumber;
const int StringRules::kLenBytesFieldNumber;
const int StringRules::kMinBytesFieldNumber;
const int StringRules::kMaxBytesFieldNumber;
const int StringRules::kPatternFieldNumber;
const int StringRules::kPrefixFieldNumber;
const int StringRules::kSuffixFieldNumber;
const int StringRules::kContainsFieldNumber;
const int StringRules::kInFieldNumber;
const int StringRules::kNotInFieldNumber;
const int StringRules::kEmailFieldNumber;
const int StringRules::kHostnameFieldNumber;
const int StringRules::kIpFieldNumber;
const int StringRules::kIpv4FieldNumber;
const int StringRules::kIpv6FieldNumber;
const int StringRules::kUriFieldNumber;
const int StringRules::kUriRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringRules::StringRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.StringRules)
}
StringRules::StringRules(const StringRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  const__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_const_()) {
    const__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.const__);
  }
  pattern_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pattern()) {
    pattern_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pattern_);
  }
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_prefix()) {
    prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
  }
  suffix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_suffix()) {
    suffix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.suffix_);
  }
  contains_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_contains()) {
    contains_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.contains_);
  }
  ::memcpy(&min_len_, &from.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_bytes_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_bytes_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kEmail: {
      set_email(from.email());
      break;
    }
    case kHostname: {
      set_hostname(from.hostname());
      break;
    }
    case kIp: {
      set_ip(from.ip());
      break;
    }
    case kIpv4: {
      set_ipv4(from.ipv4());
      break;
    }
    case kIpv6: {
      set_ipv6(from.ipv6());
      break;
    }
    case kUri: {
      set_uri(from.uri());
      break;
    }
    case kUriRef: {
      set_uri_ref(from.uri_ref());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.StringRules)
}

void StringRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_StringRules_validate_2fvalidate_2eproto.base);
  const__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pattern_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  suffix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contains_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_bytes_) -
      reinterpret_cast<char*>(&min_len_)) + sizeof(len_bytes_));
  clear_has_well_known();
}

StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:validate.StringRules)
  SharedDtor();
}

void StringRules::SharedDtor() {
  const__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pattern_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contains_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_well_known()) {
    clear_well_known();
  }
}

void StringRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StringRules& StringRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_StringRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.StringRules)
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.StringRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      pattern_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      prefix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      suffix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      contains_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_bytes_) -
        reinterpret_cast<char*>(&min_len_)) + sizeof(min_bytes_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&max_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_bytes_) -
        reinterpret_cast<char*>(&max_bytes_)) + sizeof(len_bytes_));
  }
  clear_well_known();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* StringRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<StringRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("validate.StringRules.const");
        object = msg->mutable_const_();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 min_len = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_min_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 max_len = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_max_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 min_bytes = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_min_bytes(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 max_bytes = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_max_bytes(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string pattern = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("validate.StringRules.pattern");
        object = msg->mutable_pattern();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string prefix = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("validate.StringRules.prefix");
        object = msg->mutable_prefix();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string suffix = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("validate.StringRules.suffix");
        object = msg->mutable_suffix();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string contains = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("validate.StringRules.contains");
        object = msg->mutable_contains();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated string in = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          ctx->extra_parse_data().SetFieldName("validate.StringRules.in");
          object = msg->add_in();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 82 && (ptr += 1));
        break;
      }
      // repeated string not_in = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          ctx->extra_parse_data().SetFieldName("validate.StringRules.not_in");
          object = msg->add_not_in();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 90 && (ptr += 1));
        break;
      }
      // optional bool email = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_email(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool hostname = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_hostname(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool ip = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 112) goto handle_unusual;
        msg->set_ip(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool ipv4 = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 120) goto handle_unusual;
        msg->set_ipv4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool ipv6 = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 128) goto handle_unusual;
        msg->set_ipv6(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool uri = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 136) goto handle_unusual;
        msg->set_uri(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool uri_ref = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 144) goto handle_unusual;
        msg->set_uri_ref(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 len = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 152) goto handle_unusual;
        msg->set_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 len_bytes = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 160) goto handle_unusual;
        msg->set_len_bytes(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool StringRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.StringRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_const_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->const_().data(), static_cast<int>(this->const_().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.const");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 min_len = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_min_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 max_len = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_max_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 min_bytes = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_min_bytes(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_bytes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 max_bytes = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_max_bytes(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_bytes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string pattern = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pattern()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pattern().data(), static_cast<int>(this->pattern().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.pattern");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string prefix = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_prefix()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->prefix().data(), static_cast<int>(this->prefix().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.prefix");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string suffix = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_suffix()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->suffix().data(), static_cast<int>(this->suffix().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.suffix");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string contains = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contains()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->contains().data(), static_cast<int>(this->contains().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.contains");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string in = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (82 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_in()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->in(this->in_size() - 1).data(),
            static_cast<int>(this->in(this->in_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.in");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string not_in = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_not_in()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->not_in(this->not_in_size() - 1).data(),
            static_cast<int>(this->not_in(this->not_in_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.StringRules.not_in");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool email = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.email_)));
          set_has_email();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool hostname = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.hostname_)));
          set_has_hostname();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ip = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (112 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.ip_)));
          set_has_ip();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ipv4 = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.ipv4_)));
          set_has_ipv4();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ipv6 = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (128 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.ipv6_)));
          set_has_ipv6();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool uri = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (136 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.uri_)));
          set_has_uri();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool uri_ref = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (144 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.uri_ref_)));
          set_has_uri_ref();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len_bytes = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (160 & 0xFF)) {
          HasBitSetters::set_has_len_bytes(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_bytes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.StringRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.StringRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void StringRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.StringRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->const_().data(), static_cast<int>(this->const_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.const");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->const_(), output);
  }

  // optional uint64 min_len = 2;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->min_len(), output);
  }

  // optional uint64 max_len = 3;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->max_len(), output);
  }

  // optional uint64 min_bytes = 4;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->min_bytes(), output);
  }

  // optional uint64 max_bytes = 5;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->max_bytes(), output);
  }

  // optional string pattern = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pattern().data(), static_cast<int>(this->pattern().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.pattern");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->pattern(), output);
  }

  // optional string prefix = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->prefix().data(), static_cast<int>(this->prefix().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.prefix");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->prefix(), output);
  }

  // optional string suffix = 8;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->suffix().data(), static_cast<int>(this->suffix().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.suffix");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->suffix(), output);
  }

  // optional string contains = 9;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contains().data(), static_cast<int>(this->contains().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.contains");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->contains(), output);
  }

  // repeated string in = 10;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->in(i).data(), static_cast<int>(this->in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.in");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->in(i), output);
  }

  // repeated string not_in = 11;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->not_in(i).data(), static_cast<int>(this->not_in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.not_in");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->not_in(i), output);
  }

  switch (well_known_case()) {
    case kEmail:
      ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->email(), output);
      break;
    case kHostname:
      ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->hostname(), output);
      break;
    case kIp:
      ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->ip(), output);
      break;
    case kIpv4:
      ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->ipv4(), output);
      break;
    case kIpv6:
      ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->ipv6(), output);
      break;
    case kUri:
      ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->uri(), output);
      break;
    case kUriRef:
      ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->uri_ref(), output);
      break;
    default: ;
  }
  // optional uint64 len = 19;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->len(), output);
  }

  // optional uint64 len_bytes = 20;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(20, this->len_bytes(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.StringRules)
}

::google::protobuf::uint8* StringRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.StringRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->const_().data(), static_cast<int>(this->const_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.const");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->const_(), target);
  }

  // optional uint64 min_len = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->min_len(), target);
  }

  // optional uint64 max_len = 3;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->max_len(), target);
  }

  // optional uint64 min_bytes = 4;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->min_bytes(), target);
  }

  // optional uint64 max_bytes = 5;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->max_bytes(), target);
  }

  // optional string pattern = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pattern().data(), static_cast<int>(this->pattern().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.pattern");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->pattern(), target);
  }

  // optional string prefix = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->prefix().data(), static_cast<int>(this->prefix().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.prefix");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->prefix(), target);
  }

  // optional string suffix = 8;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->suffix().data(), static_cast<int>(this->suffix().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.suffix");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->suffix(), target);
  }

  // optional string contains = 9;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contains().data(), static_cast<int>(this->contains().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.contains");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->contains(), target);
  }

  // repeated string in = 10;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->in(i).data(), static_cast<int>(this->in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.in");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(10, this->in(i), target);
  }

  // repeated string not_in = 11;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->not_in(i).data(), static_cast<int>(this->not_in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.StringRules.not_in");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(11, this->not_in(i), target);
  }

  switch (well_known_case()) {
    case kEmail:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->email(), target);
      break;
    case kHostname:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->hostname(), target);
      break;
    case kIp:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->ip(), target);
      break;
    case kIpv4:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->ipv4(), target);
      break;
    case kIpv6:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->ipv6(), target);
      break;
    case kUri:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->uri(), target);
      break;
    case kUriRef:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->uri_ref(), target);
      break;
    default: ;
  }
  // optional uint64 len = 19;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(19, this->len(), target);
  }

  // optional uint64 len_bytes = 20;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(20, this->len_bytes(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.StringRules)
  return target;
}

size_t StringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.StringRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 10;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->in_size());
  for (int i = 0, n = this->in_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->in(i));
  }

  // repeated string not_in = 11;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->not_in_size());
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->not_in(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->const_());
    }

    // optional string pattern = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pattern());
    }

    // optional string prefix = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->prefix());
    }

    // optional string suffix = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->suffix());
    }

    // optional string contains = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contains());
    }

    // optional uint64 min_len = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_len());
    }

    // optional uint64 max_len = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_len());
    }

    // optional uint64 min_bytes = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_bytes());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 max_bytes = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_bytes());
    }

    // optional uint64 len = 19;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->len());
    }

    // optional uint64 len_bytes = 20;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->len_bytes());
    }

  }
  switch (well_known_case()) {
    // optional bool email = 12;
    case kEmail: {
      total_size += 1 + 1;
      break;
    }
    // optional bool hostname = 13;
    case kHostname: {
      total_size += 1 + 1;
      break;
    }
    // optional bool ip = 14;
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // optional bool ipv4 = 15;
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // optional bool ipv6 = 16;
    case kIpv6: {
      total_size += 2 + 1;
      break;
    }
    // optional bool uri = 17;
    case kUri: {
      total_size += 2 + 1;
      break;
    }
    // optional bool uri_ref = 18;
    case kUriRef: {
      total_size += 2 + 1;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.StringRules)
  GOOGLE_DCHECK_NE(&from, this);
  const StringRules* source =
      ::google::protobuf::DynamicCastToGenerated<StringRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.StringRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.StringRules)
    MergeFrom(*source);
  }
}

void StringRules::MergeFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.StringRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      const__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.const__);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      pattern_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pattern_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      suffix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.suffix_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      contains_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.contains_);
    }
    if (cached_has_bits & 0x00000020u) {
      min_len_ = from.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_len_ = from.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_bytes_ = from.min_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      max_bytes_ = from.max_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000400u) {
      len_bytes_ = from.len_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kEmail: {
      set_email(from.email());
      break;
    }
    case kHostname: {
      set_hostname(from.hostname());
      break;
    }
    case kIp: {
      set_ip(from.ip());
      break;
    }
    case kIpv4: {
      set_ipv4(from.ipv4());
      break;
    }
    case kIpv6: {
      set_ipv6(from.ipv6());
      break;
    }
    case kUri: {
      set_uri(from.uri());
      break;
    }
    case kUriRef: {
      set_uri_ref(from.uri_ref());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
}

void StringRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringRules::IsInitialized() const {
  return true;
}

void StringRules::Swap(StringRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringRules::InternalSwap(StringRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(CastToBase(&other->in_));
  not_in_.InternalSwap(CastToBase(&other->not_in_));
  const__.Swap(&other->const__, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  pattern_.Swap(&other->pattern_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  prefix_.Swap(&other->prefix_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  suffix_.Swap(&other->suffix_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  contains_.Swap(&other->contains_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(min_len_, other->min_len_);
  swap(max_len_, other->max_len_);
  swap(min_bytes_, other->min_bytes_);
  swap(max_bytes_, other->max_bytes_);
  swap(len_, other->len_);
  swap(len_bytes_, other->len_bytes_);
  swap(well_known_, other->well_known_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata StringRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void BytesRules::InitAsDefaultInstance() {
  ::validate::_BytesRules_default_instance_.ip_ = false;
  ::validate::_BytesRules_default_instance_.ipv4_ = false;
  ::validate::_BytesRules_default_instance_.ipv6_ = false;
}
class BytesRules::HasBitSetters {
 public:
  static void set_has_const_(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_len(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_min_len(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_max_len(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_pattern(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_prefix(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_suffix(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_contains(BytesRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BytesRules::kConstFieldNumber;
const int BytesRules::kLenFieldNumber;
const int BytesRules::kMinLenFieldNumber;
const int BytesRules::kMaxLenFieldNumber;
const int BytesRules::kPatternFieldNumber;
const int BytesRules::kPrefixFieldNumber;
const int BytesRules::kSuffixFieldNumber;
const int BytesRules::kContainsFieldNumber;
const int BytesRules::kInFieldNumber;
const int BytesRules::kNotInFieldNumber;
const int BytesRules::kIpFieldNumber;
const int BytesRules::kIpv4FieldNumber;
const int BytesRules::kIpv6FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BytesRules::BytesRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.BytesRules)
}
BytesRules::BytesRules(const BytesRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  const__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_const_()) {
    const__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.const__);
  }
  pattern_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pattern()) {
    pattern_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pattern_);
  }
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_prefix()) {
    prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
  }
  suffix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_suffix()) {
    suffix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.suffix_);
  }
  contains_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_contains()) {
    contains_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.contains_);
  }
  ::memcpy(&min_len_, &from.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kIp: {
      set_ip(from.ip());
      break;
    }
    case kIpv4: {
      set_ipv4(from.ipv4());
      break;
    }
    case kIpv6: {
      set_ipv6(from.ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.BytesRules)
}

void BytesRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_BytesRules_validate_2fvalidate_2eproto.base);
  const__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pattern_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  suffix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contains_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  clear_has_well_known();
}

BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:validate.BytesRules)
  SharedDtor();
}

void BytesRules::SharedDtor() {
  const__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pattern_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contains_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_well_known()) {
    clear_well_known();
  }
}

void BytesRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BytesRules& BytesRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_BytesRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.BytesRules)
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BytesRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      pattern_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      prefix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      suffix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      contains_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  }
  clear_well_known();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BytesRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<BytesRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bytes const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_const_();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 min_len = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_min_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 max_len = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_max_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string pattern = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("validate.BytesRules.pattern");
        object = msg->mutable_pattern();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes prefix = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_prefix();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes suffix = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_suffix();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes contains = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_contains();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated bytes in = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_in();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 66 && (ptr += 1));
        break;
      }
      // repeated bytes not_in = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_not_in();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 74 && (ptr += 1));
        break;
      }
      // optional bool ip = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        msg->set_ip(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool ipv4 = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        msg->set_ipv4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool ipv6 = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_ipv6(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 len = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BytesRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.BytesRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_const_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 min_len = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_min_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 max_len = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_max_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string pattern = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pattern()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pattern().data(), static_cast<int>(this->pattern().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.BytesRules.pattern");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes prefix = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prefix()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes suffix = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_suffix()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes contains = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_contains()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes in = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_in()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes not_in = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_not_in()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ip = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.ip_)));
          set_has_ip();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ipv4 = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.ipv4_)));
          set_has_ipv4();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ipv6 = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          clear_well_known();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &well_known_.ipv6_)));
          set_has_ipv6();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 len = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.BytesRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.BytesRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BytesRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.BytesRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->const_(), output);
  }

  // optional uint64 min_len = 2;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->min_len(), output);
  }

  // optional uint64 max_len = 3;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->max_len(), output);
  }

  // optional string pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pattern().data(), static_cast<int>(this->pattern().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.BytesRules.pattern");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->pattern(), output);
  }

  // optional bytes prefix = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->prefix(), output);
  }

  // optional bytes suffix = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->suffix(), output);
  }

  // optional bytes contains = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->contains(), output);
  }

  // repeated bytes in = 8;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->in(i), output);
  }

  // repeated bytes not_in = 9;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->not_in(i), output);
  }

  switch (well_known_case()) {
    case kIp:
      ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->ip(), output);
      break;
    case kIpv4:
      ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->ipv4(), output);
      break;
    case kIpv6:
      ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->ipv6(), output);
      break;
    default: ;
  }
  // optional uint64 len = 13;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->len(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.BytesRules)
}

::google::protobuf::uint8* BytesRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.BytesRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes const = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->const_(), target);
  }

  // optional uint64 min_len = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->min_len(), target);
  }

  // optional uint64 max_len = 3;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->max_len(), target);
  }

  // optional string pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pattern().data(), static_cast<int>(this->pattern().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.BytesRules.pattern");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->pattern(), target);
  }

  // optional bytes prefix = 5;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->prefix(), target);
  }

  // optional bytes suffix = 6;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->suffix(), target);
  }

  // optional bytes contains = 7;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->contains(), target);
  }

  // repeated bytes in = 8;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(8, this->in(i), target);
  }

  // repeated bytes not_in = 9;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(9, this->not_in(i), target);
  }

  switch (well_known_case()) {
    case kIp:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->ip(), target);
      break;
    case kIpv4:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->ipv4(), target);
      break;
    case kIpv6:
      target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->ipv6(), target);
      break;
    default: ;
  }
  // optional uint64 len = 13;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->len(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BytesRules)
  return target;
}

size_t BytesRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.BytesRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes in = 8;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->in_size());
  for (int i = 0, n = this->in_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->in(i));
  }

  // repeated bytes not_in = 9;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->not_in_size());
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->not_in(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->const_());
    }

    // optional string pattern = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pattern());
    }

    // optional bytes prefix = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prefix());
    }

    // optional bytes suffix = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->suffix());
    }

    // optional bytes contains = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->contains());
    }

    // optional uint64 min_len = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_len());
    }

    // optional uint64 max_len = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_len());
    }

    // optional uint64 len = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->len());
    }

  }
  switch (well_known_case()) {
    // optional bool ip = 10;
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // optional bool ipv4 = 11;
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // optional bool ipv6 = 12;
    case kIpv6: {
      total_size += 1 + 1;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BytesRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.BytesRules)
  GOOGLE_DCHECK_NE(&from, this);
  const BytesRules* source =
      ::google::protobuf::DynamicCastToGenerated<BytesRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.BytesRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.BytesRules)
    MergeFrom(*source);
  }
}

void BytesRules::MergeFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.BytesRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      const__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.const__);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      pattern_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pattern_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      prefix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prefix_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      suffix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.suffix_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      contains_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.contains_);
    }
    if (cached_has_bits & 0x00000020u) {
      min_len_ = from.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_len_ = from.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kIp: {
      set_ip(from.ip());
      break;
    }
    case kIpv4: {
      set_ipv4(from.ipv4());
      break;
    }
    case kIpv6: {
      set_ipv6(from.ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
}

void BytesRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BytesRules::IsInitialized() const {
  return true;
}

void BytesRules::Swap(BytesRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BytesRules::InternalSwap(BytesRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(CastToBase(&other->in_));
  not_in_.InternalSwap(CastToBase(&other->not_in_));
  const__.Swap(&other->const__, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  pattern_.Swap(&other->pattern_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  prefix_.Swap(&other->prefix_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  suffix_.Swap(&other->suffix_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  contains_.Swap(&other->contains_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(min_len_, other->min_len_);
  swap(max_len_, other->max_len_);
  swap(len_, other->len_);
  swap(well_known_, other->well_known_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata BytesRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EnumRules::InitAsDefaultInstance() {
}
class EnumRules::HasBitSetters {
 public:
  static void set_has_const_(EnumRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_defined_only(EnumRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EnumRules::kConstFieldNumber;
const int EnumRules::kDefinedOnlyFieldNumber;
const int EnumRules::kInFieldNumber;
const int EnumRules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EnumRules::EnumRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.EnumRules)
}
EnumRules::EnumRules(const EnumRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&defined_only_) -
    reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
  // @@protoc_insertion_point(copy_constructor:validate.EnumRules)
}

void EnumRules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&defined_only_) -
      reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
}

EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:validate.EnumRules)
  SharedDtor();
}

void EnumRules::SharedDtor() {
}

void EnumRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EnumRules& EnumRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EnumRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.EnumRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&defined_only_) -
        reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EnumRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EnumRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int32 const = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_const_(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool defined_only = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_defined_only(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated int32 in = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 24) {
          do {
            msg->add_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 24 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedInt32Parser;
        object = msg->mutable_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated int32 not_in = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) == 32) {
          do {
            msg->add_not_in(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 32 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedInt32Parser;
        object = msg->mutable_not_in();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EnumRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.EnumRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 const = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_const_(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &const__)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool defined_only = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_defined_only(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &defined_only_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 in = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24u, input, this->mutable_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 not_in = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32u, input, this->mutable_not_in())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_not_in())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.EnumRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.EnumRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EnumRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.EnumRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->const_(), output);
  }

  // optional bool defined_only = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->defined_only(), output);
  }

  // repeated int32 in = 3;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->in(i), output);
  }

  // repeated int32 not_in = 4;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.EnumRules)
}

::google::protobuf::uint8* EnumRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.EnumRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->const_(), target);
  }

  // optional bool defined_only = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->defined_only(), target);
  }

  // repeated int32 in = 3;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(3, this->in_, target);

  // repeated int32 not_in = 4;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(4, this->not_in_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.EnumRules)
  return target;
}

size_t EnumRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.EnumRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 3;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 4;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->not_in_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->const_());
    }

    // optional bool defined_only = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnumRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.EnumRules)
  GOOGLE_DCHECK_NE(&from, this);
  const EnumRules* source =
      ::google::protobuf::DynamicCastToGenerated<EnumRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.EnumRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.EnumRules)
    MergeFrom(*source);
  }
}

void EnumRules::MergeFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.EnumRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      defined_only_ = from.defined_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EnumRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumRules::IsInitialized() const {
  return true;
}

void EnumRules::Swap(EnumRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EnumRules::InternalSwap(EnumRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(const__, other->const__);
  swap(defined_only_, other->defined_only_);
}

::google::protobuf::Metadata EnumRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MessageRules::InitAsDefaultInstance() {
}
class MessageRules::HasBitSetters {
 public:
  static void set_has_skip(MessageRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_required(MessageRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageRules::kSkipFieldNumber;
const int MessageRules::kRequiredFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageRules::MessageRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.MessageRules)
}
MessageRules::MessageRules(const MessageRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&skip_, &from.skip_,
    static_cast<size_t>(reinterpret_cast<char*>(&required_) -
    reinterpret_cast<char*>(&skip_)) + sizeof(required_));
  // @@protoc_insertion_point(copy_constructor:validate.MessageRules)
}

void MessageRules::SharedCtor() {
  ::memset(&skip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&required_) -
      reinterpret_cast<char*>(&skip_)) + sizeof(required_));
}

MessageRules::~MessageRules() {
  // @@protoc_insertion_point(destructor:validate.MessageRules)
  SharedDtor();
}

void MessageRules::SharedDtor() {
}

void MessageRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MessageRules& MessageRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MessageRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void MessageRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MessageRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&skip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&required_) -
      reinterpret_cast<char*>(&skip_)) + sizeof(required_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MessageRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MessageRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool skip = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_skip(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool required = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_required(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MessageRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.MessageRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool skip = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_skip(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &skip_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool required = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_required(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &required_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.MessageRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.MessageRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MessageRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.MessageRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool skip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->skip(), output);
  }

  // optional bool required = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->required(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.MessageRules)
}

::google::protobuf::uint8* MessageRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.MessageRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool skip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->skip(), target);
  }

  // optional bool required = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->required(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MessageRules)
  return target;
}

size_t MessageRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.MessageRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool skip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool required = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.MessageRules)
  GOOGLE_DCHECK_NE(&from, this);
  const MessageRules* source =
      ::google::protobuf::DynamicCastToGenerated<MessageRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.MessageRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.MessageRules)
    MergeFrom(*source);
  }
}

void MessageRules::MergeFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.MessageRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      skip_ = from.skip_;
    }
    if (cached_has_bits & 0x00000002u) {
      required_ = from.required_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MessageRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageRules::CopyFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageRules::IsInitialized() const {
  return true;
}

void MessageRules::Swap(MessageRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageRules::InternalSwap(MessageRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(skip_, other->skip_);
  swap(required_, other->required_);
}

::google::protobuf::Metadata MessageRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RepeatedRules::InitAsDefaultInstance() {
  ::validate::_RepeatedRules_default_instance_._instance.get_mutable()->items_ = const_cast< ::validate::FieldRules*>(
      ::validate::FieldRules::internal_default_instance());
}
class RepeatedRules::HasBitSetters {
 public:
  static void set_has_min_items(RepeatedRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_max_items(RepeatedRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_unique(RepeatedRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::validate::FieldRules& items(const RepeatedRules* msg);
  static void set_has_items(RepeatedRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::validate::FieldRules&
RepeatedRules::HasBitSetters::items(const RepeatedRules* msg) {
  return *msg->items_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RepeatedRules::kMinItemsFieldNumber;
const int RepeatedRules::kMaxItemsFieldNumber;
const int RepeatedRules::kUniqueFieldNumber;
const int RepeatedRules::kItemsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RepeatedRules::RepeatedRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.RepeatedRules)
}
RepeatedRules::RepeatedRules(const RepeatedRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_items()) {
    items_ = new ::validate::FieldRules(*from.items_);
  } else {
    items_ = nullptr;
  }
  ::memcpy(&min_items_, &from.min_items_,
    static_cast<size_t>(reinterpret_cast<char*>(&unique_) -
    reinterpret_cast<char*>(&min_items_)) + sizeof(unique_));
  // @@protoc_insertion_point(copy_constructor:validate.RepeatedRules)
}

void RepeatedRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  ::memset(&items_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&unique_) -
      reinterpret_cast<char*>(&items_)) + sizeof(unique_));
}

RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:validate.RepeatedRules)
  SharedDtor();
}

void RepeatedRules::SharedDtor() {
  if (this != internal_default_instance()) delete items_;
}

void RepeatedRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RepeatedRules& RepeatedRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.RepeatedRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(items_ != nullptr);
    items_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&min_items_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unique_) -
        reinterpret_cast<char*>(&min_items_)) + sizeof(unique_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RepeatedRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RepeatedRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 min_items = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_min_items(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 max_items = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_max_items(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool unique = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_unique(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .validate.FieldRules items = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::FieldRules::_InternalParse;
        object = msg->mutable_items();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RepeatedRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.RepeatedRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 min_items = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_min_items(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_items_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 max_items = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_max_items(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_items_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool unique = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_unique(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unique_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.FieldRules items = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_items()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.RepeatedRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.RepeatedRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RepeatedRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.RepeatedRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_items = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->min_items(), output);
  }

  // optional uint64 max_items = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->max_items(), output);
  }

  // optional bool unique = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->unique(), output);
  }

  // optional .validate.FieldRules items = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::items(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.RepeatedRules)
}

::google::protobuf::uint8* RepeatedRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.RepeatedRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_items = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->min_items(), target);
  }

  // optional uint64 max_items = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->max_items(), target);
  }

  // optional bool unique = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->unique(), target);
  }

  // optional .validate.FieldRules items = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::items(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.RepeatedRules)
  return target;
}

size_t RepeatedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.RepeatedRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .validate.FieldRules items = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *items_);
    }

    // optional uint64 min_items = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_items());
    }

    // optional uint64 max_items = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_items());
    }

    // optional bool unique = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepeatedRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.RepeatedRules)
  GOOGLE_DCHECK_NE(&from, this);
  const RepeatedRules* source =
      ::google::protobuf::DynamicCastToGenerated<RepeatedRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.RepeatedRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.RepeatedRules)
    MergeFrom(*source);
  }
}

void RepeatedRules::MergeFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.RepeatedRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_items()->::validate::FieldRules::MergeFrom(from.items());
    }
    if (cached_has_bits & 0x00000002u) {
      min_items_ = from.min_items_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_items_ = from.max_items_;
    }
    if (cached_has_bits & 0x00000008u) {
      unique_ = from.unique_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RepeatedRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedRules::IsInitialized() const {
  return true;
}

void RepeatedRules::Swap(RepeatedRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RepeatedRules::InternalSwap(RepeatedRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(items_, other->items_);
  swap(min_items_, other->min_items_);
  swap(max_items_, other->max_items_);
  swap(unique_, other->unique_);
}

::google::protobuf::Metadata RepeatedRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MapRules::InitAsDefaultInstance() {
  ::validate::_MapRules_default_instance_._instance.get_mutable()->keys_ = const_cast< ::validate::FieldRules*>(
      ::validate::FieldRules::internal_default_instance());
  ::validate::_MapRules_default_instance_._instance.get_mutable()->values_ = const_cast< ::validate::FieldRules*>(
      ::validate::FieldRules::internal_default_instance());
}
class MapRules::HasBitSetters {
 public:
  static void set_has_min_pairs(MapRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_max_pairs(MapRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_no_sparse(MapRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::validate::FieldRules& keys(const MapRules* msg);
  static void set_has_keys(MapRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::validate::FieldRules& values(const MapRules* msg);
  static void set_has_values(MapRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::validate::FieldRules&
MapRules::HasBitSetters::keys(const MapRules* msg) {
  return *msg->keys_;
}
const ::validate::FieldRules&
MapRules::HasBitSetters::values(const MapRules* msg) {
  return *msg->values_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapRules::kMinPairsFieldNumber;
const int MapRules::kMaxPairsFieldNumber;
const int MapRules::kNoSparseFieldNumber;
const int MapRules::kKeysFieldNumber;
const int MapRules::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapRules::MapRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.MapRules)
}
MapRules::MapRules(const MapRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_keys()) {
    keys_ = new ::validate::FieldRules(*from.keys_);
  } else {
    keys_ = nullptr;
  }
  if (from.has_values()) {
    values_ = new ::validate::FieldRules(*from.values_);
  } else {
    values_ = nullptr;
  }
  ::memcpy(&min_pairs_, &from.min_pairs_,
    static_cast<size_t>(reinterpret_cast<char*>(&no_sparse_) -
    reinterpret_cast<char*>(&min_pairs_)) + sizeof(no_sparse_));
  // @@protoc_insertion_point(copy_constructor:validate.MapRules)
}

void MapRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  ::memset(&keys_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&no_sparse_) -
      reinterpret_cast<char*>(&keys_)) + sizeof(no_sparse_));
}

MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:validate.MapRules)
  SharedDtor();
}

void MapRules::SharedDtor() {
  if (this != internal_default_instance()) delete keys_;
  if (this != internal_default_instance()) delete values_;
}

void MapRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MapRules& MapRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FieldRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MapRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(keys_ != nullptr);
      keys_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(values_ != nullptr);
      values_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&min_pairs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&no_sparse_) -
        reinterpret_cast<char*>(&min_pairs_)) + sizeof(no_sparse_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MapRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MapRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 min_pairs = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_min_pairs(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 max_pairs = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_max_pairs(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool no_sparse = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_no_sparse(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .validate.FieldRules keys = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::FieldRules::_InternalParse;
        object = msg->mutable_keys();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .validate.FieldRules values = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::validate::FieldRules::_InternalParse;
        object = msg->mutable_values();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MapRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.MapRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 min_pairs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_min_pairs(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_pairs_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 max_pairs = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_max_pairs(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_pairs_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool no_sparse = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_no_sparse(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &no_sparse_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.FieldRules keys = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_keys()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .validate.FieldRules values = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.MapRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.MapRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MapRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.MapRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_pairs = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->min_pairs(), output);
  }

  // optional uint64 max_pairs = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->max_pairs(), output);
  }

  // optional bool no_sparse = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->no_sparse(), output);
  }

  // optional .validate.FieldRules keys = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::keys(this), output);
  }

  // optional .validate.FieldRules values = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::values(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.MapRules)
}

::google::protobuf::uint8* MapRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.MapRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_pairs = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->min_pairs(), target);
  }

  // optional uint64 max_pairs = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->max_pairs(), target);
  }

  // optional bool no_sparse = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->no_sparse(), target);
  }

  // optional .validate.FieldRules keys = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::keys(this), target);
  }

  // optional .validate.FieldRules values = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::values(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MapRules)
  return target;
}

size_t MapRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.MapRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .validate.FieldRules keys = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *keys_);
    }

    // optional .validate.FieldRules values = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *values_);
    }

    // optional uint64 min_pairs = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_pairs());
    }

    // optional uint64 max_pairs = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_pairs());
    }

    // optional bool no_sparse = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.MapRules)
  GOOGLE_DCHECK_NE(&from, this);
  const MapRules* source =
      ::google::protobuf::DynamicCastToGenerated<MapRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.MapRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.MapRules)
    MergeFrom(*source);
  }
}

void MapRules::MergeFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.MapRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_keys()->::validate::FieldRules::MergeFrom(from.keys());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_values()->::validate::FieldRules::MergeFrom(from.values());
    }
    if (cached_has_bits & 0x00000004u) {
      min_pairs_ = from.min_pairs_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_pairs_ = from.max_pairs_;
    }
    if (cached_has_bits & 0x00000010u) {
      no_sparse_ = from.no_sparse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MapRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapRules::IsInitialized() const {
  return true;
}

void MapRules::Swap(MapRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapRules::InternalSwap(MapRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(keys_, other->keys_);
  swap(values_, other->values_);
  swap(min_pairs_, other->min_pairs_);
  swap(max_pairs_, other->max_pairs_);
  swap(no_sparse_, other->no_sparse_);
}

::google::protobuf::Metadata MapRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AnyRules::InitAsDefaultInstance() {
}
class AnyRules::HasBitSetters {
 public:
  static void set_has_required(AnyRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AnyRules::kRequiredFieldNumber;
const int AnyRules::kInFieldNumber;
const int AnyRules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AnyRules::AnyRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.AnyRules)
}
AnyRules::AnyRules(const AnyRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  required_ = from.required_;
  // @@protoc_insertion_point(copy_constructor:validate.AnyRules)
}

void AnyRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AnyRules_validate_2fvalidate_2eproto.base);
  required_ = false;
}

AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:validate.AnyRules)
  SharedDtor();
}

void AnyRules::SharedDtor() {
}

void AnyRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AnyRules& AnyRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AnyRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.AnyRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  required_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AnyRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<AnyRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool required = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_required(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated string in = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          ctx->extra_parse_data().SetFieldName("validate.AnyRules.in");
          object = msg->add_in();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // repeated string not_in = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          ctx->extra_parse_data().SetFieldName("validate.AnyRules.not_in");
          object = msg->add_not_in();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AnyRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.AnyRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool required = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_required(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &required_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string in = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_in()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->in(this->in_size() - 1).data(),
            static_cast<int>(this->in(this->in_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.AnyRules.in");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string not_in = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_not_in()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->not_in(this->not_in_size() - 1).data(),
            static_cast<int>(this->not_in(this->not_in_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "validate.AnyRules.not_in");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.AnyRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.AnyRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AnyRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.AnyRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->required(), output);
  }

  // repeated string in = 2;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->in(i).data(), static_cast<int>(this->in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.in");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->in(i), output);
  }

  // repeated string not_in = 3;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->not_in(i).data(), static_cast<int>(this->not_in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.not_in");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->not_in(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.AnyRules)
}

::google::protobuf::uint8* AnyRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.AnyRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->required(), target);
  }

  // repeated string in = 2;
  for (int i = 0, n = this->in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->in(i).data(), static_cast<int>(this->in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.in");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->in(i), target);
  }

  // repeated string not_in = 3;
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->not_in(i).data(), static_cast<int>(this->not_in(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.not_in");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->not_in(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.AnyRules)
  return target;
}

size_t AnyRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.AnyRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->in_size());
  for (int i = 0, n = this->in_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->in(i));
  }

  // repeated string not_in = 3;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->not_in_size());
  for (int i = 0, n = this->not_in_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->not_in(i));
  }

  // optional bool required = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AnyRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.AnyRules)
  GOOGLE_DCHECK_NE(&from, this);
  const AnyRules* source =
      ::google::protobuf::DynamicCastToGenerated<AnyRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.AnyRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.AnyRules)
    MergeFrom(*source);
  }
}

void AnyRules::MergeFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.AnyRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  if (from.has_required()) {
    set_required(from.required());
  }
}

void AnyRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyRules::IsInitialized() const {
  return true;
}

void AnyRules::Swap(AnyRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AnyRules::InternalSwap(AnyRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(CastToBase(&other->in_));
  not_in_.InternalSwap(CastToBase(&other->not_in_));
  swap(required_, other->required_);
}

::google::protobuf::Metadata AnyRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void DurationRules::InitAsDefaultInstance() {
  ::validate::_DurationRules_default_instance_._instance.get_mutable()->const__ = const_cast< ::google::protobuf::Duration*>(
      ::google::protobuf::Duration::internal_default_instance());
  ::validate::_DurationRules_default_instance_._instance.get_mutable()->lt_ = const_cast< ::google::protobuf::Duration*>(
      ::google::protobuf::Duration::internal_default_instance());
  ::validate::_DurationRules_default_instance_._instance.get_mutable()->lte_ = const_cast< ::google::protobuf::Duration*>(
      ::google::protobuf::Duration::internal_default_instance());
  ::validate::_DurationRules_default_instance_._instance.get_mutable()->gt_ = const_cast< ::google::protobuf::Duration*>(
      ::google::protobuf::Duration::internal_default_instance());
  ::validate::_DurationRules_default_instance_._instance.get_mutable()->gte_ = const_cast< ::google::protobuf::Duration*>(
      ::google::protobuf::Duration::internal_default_instance());
}
class DurationRules::HasBitSetters {
 public:
  static void set_has_required(DurationRules* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::google::protobuf::Duration& const_(const DurationRules* msg);
  static void set_has_const_(DurationRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::google::protobuf::Duration& lt(const DurationRules* msg);
  static void set_has_lt(DurationRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::google::protobuf::Duration& lte(const DurationRules* msg);
  static void set_has_lte(DurationRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::google::protobuf::Duration& gt(const DurationRules* msg);
  static void set_has_gt(DurationRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::google::protobuf::Duration& gte(const DurationRules* msg);
  static void set_has_gte(DurationRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::google::protobuf::Duration&
DurationRules::HasBitSetters::const_(const DurationRules* msg) {
  return *msg->const__;
}
const ::google::protobuf::Duration&
DurationRules::HasBitSetters::lt(const DurationRules* msg) {
  return *msg->lt_;
}
const ::google::protobuf::Duration&
DurationRules::HasBitSetters::lte(const DurationRules* msg) {
  return *msg->lte_;
}
const ::google::protobuf::Duration&
DurationRules::HasBitSetters::gt(const DurationRules* msg) {
  return *msg->gt_;
}
const ::google::protobuf::Duration&
DurationRules::HasBitSetters::gte(const DurationRules* msg) {
  return *msg->gte_;
}
void DurationRules::clear_const_() {
  if (const__ != nullptr) const__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void DurationRules::clear_lt() {
  if (lt_ != nullptr) lt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void DurationRules::clear_lte() {
  if (lte_ != nullptr) lte_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void DurationRules::clear_gt() {
  if (gt_ != nullptr) gt_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void DurationRules::clear_gte() {
  if (gte_ != nullptr) gte_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void DurationRules::clear_in() {
  in_.Clear();
}
void DurationRules::clear_not_in() {
  not_in_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DurationRules::kRequiredFieldNumber;
const int DurationRules::kConstFieldNumber;
const int DurationRules::kLtFieldNumber;
const int DurationRules::kLteFieldNumber;
const int DurationRules::kGtFieldNumber;
const int DurationRules::kGteFieldNumber;
const int DurationRules::kInFieldNumber;
const int DurationRules::kNotInFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DurationRules::DurationRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.DurationRules)
}
DurationRules::DurationRules(const DurationRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_const_()) {
    const__ = new ::google::protobuf::Duration(*from.const__);
  } else {
    const__ = nullptr;
  }
  if (from.has_lt()) {
    lt_ = new ::google::protobuf::Duration(*from.lt_);
  } else {
    lt_ = nullptr;
  }
  if (from.has_lte()) {
    lte_ = new ::google::protobuf::Duration(*from.lte_);
  } else {
    lte_ = nullptr;
  }
  if (from.has_gt()) {
    gt_ = new ::google::protobuf::Duration(*from.gt_);
  } else {
    gt_ = nullptr;
  }
  if (from.has_gte()) {
    gte_ = new ::google::protobuf::Duration(*from.gte_);
  } else {
    gte_ = nullptr;
  }
  required_ = from.required_;
  // @@protoc_insertion_point(copy_constructor:validate.DurationRules)
}

void DurationRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_DurationRules_validate_2fvalidate_2eproto.base);
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&required_) -
      reinterpret_cast<char*>(&const__)) + sizeof(required_));
}

DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:validate.DurationRules)
  SharedDtor();
}

void DurationRules::SharedDtor() {
  if (this != internal_default_instance()) delete const__;
  if (this != internal_default_instance()) delete lt_;
  if (this != internal_default_instance()) delete lte_;
  if (this != internal_default_instance()) delete gt_;
  if (this != internal_default_instance()) delete gte_;
}

void DurationRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DurationRules& DurationRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_DurationRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DurationRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(const__ != nullptr);
      const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lt_ != nullptr);
      lt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(lte_ != nullptr);
      lte_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(gt_ != nullptr);
      gt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(gte_ != nullptr);
      gte_->Clear();
    }
  }
  required_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DurationRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<DurationRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool required = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_required(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .google.protobuf.Duration const = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Duration::_InternalParse;
        object = msg->mutable_const_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Duration lt = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Duration::_InternalParse;
        object = msg->mutable_lt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Duration lte = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Duration::_InternalParse;
        object = msg->mutable_lte();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Duration gt = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Duration::_InternalParse;
        object = msg->mutable_gt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Duration gte = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Duration::_InternalParse;
        object = msg->mutable_gte();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // repeated .google.protobuf.Duration in = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::Duration::_InternalParse;
          object = msg->add_in();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 58 && (ptr += 1));
        break;
      }
      // repeated .google.protobuf.Duration not_in = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::Duration::_InternalParse;
          object = msg->add_not_in();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 66 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DurationRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.DurationRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool required = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_required(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &required_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Duration const = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_const_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Duration lt = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Duration lte = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lte()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Duration gt = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_gt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Duration gte = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_gte()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .google.protobuf.Duration in = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_in()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .google.protobuf.Duration not_in = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_not_in()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.DurationRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.DurationRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DurationRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.DurationRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->required(), output);
  }

  // optional .google.protobuf.Duration const = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::const_(this), output);
  }

  // optional .google.protobuf.Duration lt = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::lt(this), output);
  }

  // optional .google.protobuf.Duration lte = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::lte(this), output);
  }

  // optional .google.protobuf.Duration gt = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::gt(this), output);
  }

  // optional .google.protobuf.Duration gte = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::gte(this), output);
  }

  // repeated .google.protobuf.Duration in = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->in_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7,
      this->in(static_cast<int>(i)),
      output);
  }

  // repeated .google.protobuf.Duration not_in = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->not_in_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8,
      this->not_in(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.DurationRules)
}

::google::protobuf::uint8* DurationRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.DurationRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->required(), target);
  }

  // optional .google.protobuf.Duration const = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::const_(this), target);
  }

  // optional .google.protobuf.Duration lt = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::lt(this), target);
  }

  // optional .google.protobuf.Duration lte = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::lte(this), target);
  }

  // optional .google.protobuf.Duration gt = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::gt(this), target);
  }

  // optional .google.protobuf.Duration gte = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::gte(this), target);
  }

  // repeated .google.protobuf.Duration in = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->in_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->in(static_cast<int>(i)), target);
  }

  // repeated .google.protobuf.Duration not_in = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->not_in_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, this->not_in(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DurationRules)
  return target;
}

size_t DurationRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.DurationRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Duration in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->in_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->in(static_cast<int>(i)));
    }
  }

  // repeated .google.protobuf.Duration not_in = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->not_in_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->not_in(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .google.protobuf.Duration const = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *const__);
    }

    // optional .google.protobuf.Duration lt = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lt_);
    }

    // optional .google.protobuf.Duration lte = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lte_);
    }

    // optional .google.protobuf.Duration gt = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *gt_);
    }

    // optional .google.protobuf.Duration gte = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *gte_);
    }

    // optional bool required = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DurationRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.DurationRules)
  GOOGLE_DCHECK_NE(&from, this);
  const DurationRules* source =
      ::google::protobuf::DynamicCastToGenerated<DurationRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.DurationRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.DurationRules)
    MergeFrom(*source);
  }
}

void DurationRules::MergeFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.DurationRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_const_()->::google::protobuf::Duration::MergeFrom(from.const_());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_lt()->::google::protobuf::Duration::MergeFrom(from.lt());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_lte()->::google::protobuf::Duration::MergeFrom(from.lte());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_gt()->::google::protobuf::Duration::MergeFrom(from.gt());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_gte()->::google::protobuf::Duration::MergeFrom(from.gte());
    }
    if (cached_has_bits & 0x00000020u) {
      required_ = from.required_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DurationRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationRules::IsInitialized() const {
  return true;
}

void DurationRules::Swap(DurationRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DurationRules::InternalSwap(DurationRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&in_)->InternalSwap(CastToBase(&other->in_));
  CastToBase(&not_in_)->InternalSwap(CastToBase(&other->not_in_));
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
  swap(required_, other->required_);
}

::google::protobuf::Metadata DurationRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TimestampRules::InitAsDefaultInstance() {
  ::validate::_TimestampRules_default_instance_._instance.get_mutable()->const__ = const_cast< ::google::protobuf::Timestamp*>(
      ::google::protobuf::Timestamp::internal_default_instance());
  ::validate::_TimestampRules_default_instance_._instance.get_mutable()->lt_ = const_cast< ::google::protobuf::Timestamp*>(
      ::google::protobuf::Timestamp::internal_default_instance());
  ::validate::_TimestampRules_default_instance_._instance.get_mutable()->lte_ = const_cast< ::google::protobuf::Timestamp*>(
      ::google::protobuf::Timestamp::internal_default_instance());
  ::validate::_TimestampRules_default_instance_._instance.get_mutable()->gt_ = const_cast< ::google::protobuf::Timestamp*>(
      ::google::protobuf::Timestamp::internal_default_instance());
  ::validate::_TimestampRules_default_instance_._instance.get_mutable()->gte_ = const_cast< ::google::protobuf::Timestamp*>(
      ::google::protobuf::Timestamp::internal_default_instance());
  ::validate::_TimestampRules_default_instance_._instance.get_mutable()->within_ = const_cast< ::google::protobuf::Duration*>(
      ::google::protobuf::Duration::internal_default_instance());
}
class TimestampRules::HasBitSetters {
 public:
  static void set_has_required(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static const ::google::protobuf::Timestamp& const_(const TimestampRules* msg);
  static void set_has_const_(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::google::protobuf::Timestamp& lt(const TimestampRules* msg);
  static void set_has_lt(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::google::protobuf::Timestamp& lte(const TimestampRules* msg);
  static void set_has_lte(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::google::protobuf::Timestamp& gt(const TimestampRules* msg);
  static void set_has_gt(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::google::protobuf::Timestamp& gte(const TimestampRules* msg);
  static void set_has_gte(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lt_now(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_gt_now(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::google::protobuf::Duration& within(const TimestampRules* msg);
  static void set_has_within(TimestampRules* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
};

const ::google::protobuf::Timestamp&
TimestampRules::HasBitSetters::const_(const TimestampRules* msg) {
  return *msg->const__;
}
const ::google::protobuf::Timestamp&
TimestampRules::HasBitSetters::lt(const TimestampRules* msg) {
  return *msg->lt_;
}
const ::google::protobuf::Timestamp&
TimestampRules::HasBitSetters::lte(const TimestampRules* msg) {
  return *msg->lte_;
}
const ::google::protobuf::Timestamp&
TimestampRules::HasBitSetters::gt(const TimestampRules* msg) {
  return *msg->gt_;
}
const ::google::protobuf::Timestamp&
TimestampRules::HasBitSetters::gte(const TimestampRules* msg) {
  return *msg->gte_;
}
const ::google::protobuf::Duration&
TimestampRules::HasBitSetters::within(const TimestampRules* msg) {
  return *msg->within_;
}
void TimestampRules::clear_const_() {
  if (const__ != nullptr) const__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::clear_lt() {
  if (lt_ != nullptr) lt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void TimestampRules::clear_lte() {
  if (lte_ != nullptr) lte_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void TimestampRules::clear_gt() {
  if (gt_ != nullptr) gt_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void TimestampRules::clear_gte() {
  if (gte_ != nullptr) gte_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void TimestampRules::clear_within() {
  if (within_ != nullptr) within_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TimestampRules::kRequiredFieldNumber;
const int TimestampRules::kConstFieldNumber;
const int TimestampRules::kLtFieldNumber;
const int TimestampRules::kLteFieldNumber;
const int TimestampRules::kGtFieldNumber;
const int TimestampRules::kGteFieldNumber;
const int TimestampRules::kLtNowFieldNumber;
const int TimestampRules::kGtNowFieldNumber;
const int TimestampRules::kWithinFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TimestampRules::TimestampRules()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:validate.TimestampRules)
}
TimestampRules::TimestampRules(const TimestampRules& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_const_()) {
    const__ = new ::google::protobuf::Timestamp(*from.const__);
  } else {
    const__ = nullptr;
  }
  if (from.has_lt()) {
    lt_ = new ::google::protobuf::Timestamp(*from.lt_);
  } else {
    lt_ = nullptr;
  }
  if (from.has_lte()) {
    lte_ = new ::google::protobuf::Timestamp(*from.lte_);
  } else {
    lte_ = nullptr;
  }
  if (from.has_gt()) {
    gt_ = new ::google::protobuf::Timestamp(*from.gt_);
  } else {
    gt_ = nullptr;
  }
  if (from.has_gte()) {
    gte_ = new ::google::protobuf::Timestamp(*from.gte_);
  } else {
    gte_ = nullptr;
  }
  if (from.has_within()) {
    within_ = new ::google::protobuf::Duration(*from.within_);
  } else {
    within_ = nullptr;
  }
  ::memcpy(&required_, &from.required_,
    static_cast<size_t>(reinterpret_cast<char*>(&gt_now_) -
    reinterpret_cast<char*>(&required_)) + sizeof(gt_now_));
  // @@protoc_insertion_point(copy_constructor:validate.TimestampRules)
}

void TimestampRules::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TimestampRules_validate_2fvalidate_2eproto.base);
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gt_now_) -
      reinterpret_cast<char*>(&const__)) + sizeof(gt_now_));
}

TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:validate.TimestampRules)
  SharedDtor();
}

void TimestampRules::SharedDtor() {
  if (this != internal_default_instance()) delete const__;
  if (this != internal_default_instance()) delete lt_;
  if (this != internal_default_instance()) delete lte_;
  if (this != internal_default_instance()) delete gt_;
  if (this != internal_default_instance()) delete gte_;
  if (this != internal_default_instance()) delete within_;
}

void TimestampRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TimestampRules& TimestampRules::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TimestampRules_validate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.TimestampRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(const__ != nullptr);
      const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lt_ != nullptr);
      lt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(lte_ != nullptr);
      lte_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(gt_ != nullptr);
      gt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(gte_ != nullptr);
      gte_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(within_ != nullptr);
      within_->Clear();
    }
  }
  ::memset(&required_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lt_now_) -
      reinterpret_cast<char*>(&required_)) + sizeof(lt_now_));
  gt_now_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TimestampRules::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TimestampRules*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool required = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_required(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .google.protobuf.Timestamp const = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Timestamp::_InternalParse;
        object = msg->mutable_const_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Timestamp lt = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Timestamp::_InternalParse;
        object = msg->mutable_lt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Timestamp lte = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Timestamp::_InternalParse;
        object = msg->mutable_lte();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Timestamp gt = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Timestamp::_InternalParse;
        object = msg->mutable_gt();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .google.protobuf.Timestamp gte = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Timestamp::_InternalParse;
        object = msg->mutable_gte();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool lt_now = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_lt_now(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool gt_now = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_gt_now(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .google.protobuf.Duration within = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::Duration::_InternalParse;
        object = msg->mutable_within();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TimestampRules::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:validate.TimestampRules)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool required = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_required(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &required_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Timestamp const = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_const_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Timestamp lt = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Timestamp lte = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lte()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Timestamp gt = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_gt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Timestamp gte = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_gte()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool lt_now = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lt_now(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lt_now_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool gt_now = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_gt_now(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gt_now_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .google.protobuf.Duration within = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_within()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:validate.TimestampRules)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:validate.TimestampRules)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TimestampRules::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:validate.TimestampRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->required(), output);
  }

  // optional .google.protobuf.Timestamp const = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::const_(this), output);
  }

  // optional .google.protobuf.Timestamp lt = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::lt(this), output);
  }

  // optional .google.protobuf.Timestamp lte = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::lte(this), output);
  }

  // optional .google.protobuf.Timestamp gt = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::gt(this), output);
  }

  // optional .google.protobuf.Timestamp gte = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::gte(this), output);
  }

  // optional bool lt_now = 7;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->lt_now(), output);
  }

  // optional bool gt_now = 8;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->gt_now(), output);
  }

  // optional .google.protobuf.Duration within = 9;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, HasBitSetters::within(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:validate.TimestampRules)
}

::google::protobuf::uint8* TimestampRules::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.TimestampRules)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->required(), target);
  }

  // optional .google.protobuf.Timestamp const = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::const_(this), target);
  }

  // optional .google.protobuf.Timestamp lt = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::lt(this), target);
  }

  // optional .google.protobuf.Timestamp lte = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::lte(this), target);
  }

  // optional .google.protobuf.Timestamp gt = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::gt(this), target);
  }

  // optional .google.protobuf.Timestamp gte = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::gte(this), target);
  }

  // optional bool lt_now = 7;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->lt_now(), target);
  }

  // optional bool gt_now = 8;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, HasBitSetters::within(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.TimestampRules)
  return target;
}

size_t TimestampRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.TimestampRules)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .google.protobuf.Timestamp const = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *const__);
    }

    // optional .google.protobuf.Timestamp lt = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lt_);
    }

    // optional .google.protobuf.Timestamp lte = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lte_);
    }

    // optional .google.protobuf.Timestamp gt = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *gt_);
    }

    // optional .google.protobuf.Timestamp gte = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *gte_);
    }

    // optional .google.protobuf.Duration within = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *within_);
    }

    // optional bool required = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool lt_now = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool gt_now = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimestampRules::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:validate.TimestampRules)
  GOOGLE_DCHECK_NE(&from, this);
  const TimestampRules* source =
      ::google::protobuf::DynamicCastToGenerated<TimestampRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:validate.TimestampRules)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:validate.TimestampRules)
    MergeFrom(*source);
  }
}

void TimestampRules::MergeFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.TimestampRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_const_()->::google::protobuf::Timestamp::MergeFrom(from.const_());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_lt()->::google::protobuf::Timestamp::MergeFrom(from.lt());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_lte()->::google::protobuf::Timestamp::MergeFrom(from.lte());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_gt()->::google::protobuf::Timestamp::MergeFrom(from.gt());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_gte()->::google::protobuf::Timestamp::MergeFrom(from.gte());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_within()->::google::protobuf::Duration::MergeFrom(from.within());
    }
    if (cached_has_bits & 0x00000040u) {
      required_ = from.required_;
    }
    if (cached_has_bits & 0x00000080u) {
      lt_now_ = from.lt_now_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_gt_now(from.gt_now());
  }
}

void TimestampRules::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampRules::IsInitialized() const {
  return true;
}

void TimestampRules::Swap(TimestampRules* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TimestampRules::InternalSwap(TimestampRules* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(const__, other->const__);
  swap(lt_, other->lt_);
  swap(lte_, other->lte_);
  swap(gt_, other->gt_);
  swap(gte_, other->gte_);
  swap(within_, other->within_);
  swap(required_, other->required_);
  swap(lt_now_, other->lt_now_);
  swap(gt_now_, other->gt_now_);
}

::google::protobuf::Metadata TimestampRules::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_validate_2fvalidate_2eproto);
  return ::file_level_metadata_validate_2fvalidate_2eproto[kIndexInFileMessages];
}

::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  disabled(kDisabledFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  required(kRequiredFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::validate::FieldRules >, 11, false >
  rules(kRulesFieldNumber, *::validate::FieldRules::internal_default_instance());

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::validate::FieldRules* Arena::CreateMaybeMessage< ::validate::FieldRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::FieldRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::FloatRules* Arena::CreateMaybeMessage< ::validate::FloatRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::FloatRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::DoubleRules* Arena::CreateMaybeMessage< ::validate::DoubleRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::DoubleRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Int32Rules* Arena::CreateMaybeMessage< ::validate::Int32Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::Int32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Int64Rules* Arena::CreateMaybeMessage< ::validate::Int64Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::Int64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::UInt32Rules* Arena::CreateMaybeMessage< ::validate::UInt32Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::UInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::UInt64Rules* Arena::CreateMaybeMessage< ::validate::UInt64Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::UInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SInt32Rules* Arena::CreateMaybeMessage< ::validate::SInt32Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::SInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SInt64Rules* Arena::CreateMaybeMessage< ::validate::SInt64Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::SInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Fixed32Rules* Arena::CreateMaybeMessage< ::validate::Fixed32Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::Fixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Fixed64Rules* Arena::CreateMaybeMessage< ::validate::Fixed64Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::Fixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SFixed32Rules* Arena::CreateMaybeMessage< ::validate::SFixed32Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::SFixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SFixed64Rules* Arena::CreateMaybeMessage< ::validate::SFixed64Rules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::SFixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::BoolRules* Arena::CreateMaybeMessage< ::validate::BoolRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::BoolRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::StringRules* Arena::CreateMaybeMessage< ::validate::StringRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::StringRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::BytesRules* Arena::CreateMaybeMessage< ::validate::BytesRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::BytesRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::EnumRules* Arena::CreateMaybeMessage< ::validate::EnumRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::EnumRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::MessageRules* Arena::CreateMaybeMessage< ::validate::MessageRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::MessageRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::RepeatedRules* Arena::CreateMaybeMessage< ::validate::RepeatedRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::RepeatedRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::MapRules* Arena::CreateMaybeMessage< ::validate::MapRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::MapRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::AnyRules* Arena::CreateMaybeMessage< ::validate::AnyRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::AnyRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::DurationRules* Arena::CreateMaybeMessage< ::validate::DurationRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::DurationRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::TimestampRules* Arena::CreateMaybeMessage< ::validate::TimestampRules >(Arena* arena) {
  return Arena::CreateInternal< ::validate::TimestampRules >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
